<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Installation d&#8217;un home serveur Linux sur un Raspberry</title>
<date>2024-04-17</date>
<author>
<personname>
<firstname>Stéphane</firstname>
<surname>Apiou</surname>
</personname>
<email>stephane@apiou.org</email>
</author>
<authorinitials>SA</authorinitials>
<revhistory>
<revision>
<revnumber>1.3</revnumber>
<date>2024-04-17</date>
<authorinitials>SA</authorinitials>
</revision>
</revhistory>
</info>
<section xml:id="_avant_propos">
<title>Avant propos</title>
<simpara>Ce document est disponible sur le site <link xl:href="https://serveur-home-raspberry-pi.readthedocs.io">ReadTheDocs</link></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="diag-qrcode-md5-ca9d818d3232226fdda46fca34ff0de9.svg"/>
</imageobject>
<textobject><phrase>Diagram</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>et sur <link xl:href="https://github.com/stefapi/vps_installation">Github</link>. Sur Github vous trouverez aussi les versions PDF, EPUB, HTML, Docbook et Asciidoc de ce document</simpara>
<simpara>Cette documentation décrit la méthode que j&#8217;ai utilisé pour installer un serveur linux de gestion du reseau Home (site auto hébergé) avec un raspberry PI.</simpara>
<simpara>Elle est le résultat de très nombreuses heures de travail pour collecter la documentation nécessaire.</simpara>
<simpara>Le coût pour mettre en oeuvre ce type de serveur est relativement faible:</simpara>
<itemizedlist>
<listitem>
<simpara>Compter 15-18€TTC/an pour un nom de domaine classique (mais il peut y avoir des promos)</simpara>
</listitem>
<listitem>
<simpara>Comptez 47€ pour acheter une carte Raspberry PI 4 (1Go de Ram) et 67€ pour un PI 4 avec 4Go de Ram ou 94€ pour un PI 5 avec 8Go de Ram. A cela il faut ajouter un boitier, une alim et une flash de 64 ou 128 Go (prenez les cartes SD les plus rapide possible en écriture).</simpara>
</listitem>
</itemizedlist>
<simpara>Vous en aurez donc entre 80€ pour une petite Configuration Raspberry PI 4 1Go, flash de 64 Go et 160€ pour une configuration Raspberry PI 5 8 Go et une flash de 512 Go.</simpara>
<simpara>Il existe aussi des kits permettant de mettre en oeuvre des cartes NVME avec un gros gain de performance disque.</simpara>
<simpara>Par rapport à une solution VPS directement dans le cloud, ce budget correspond à 7-16 mois d&#8217;abonnement selon la configuration. Si vous avez la Fibre chez vous, il est nettement plus rentable d&#8217;utiliser un Raspberry que de prendre un abonnement VPS.</simpara>
</section>
<section xml:id="root_login">
<title>Se loguer root sur le serveur</title>
<simpara>A de nombreux endroit dans la documentation, il est demandé de se loguer root sur le serveur.
Pour se loguer root, et dans l’hypothèse que vous avez mis en place un compte sudo:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>De votre machine locale, loguez vous avec votre compte <literal>&lt;sudo_username&gt;</literal>. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh &lt;sudo_username&gt;@&lt;example.com&gt; <co xml:id="CO1-1"/></programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>Mettez ici &lt;sudo_username&gt; par votre nom de login et &lt;example.com&gt; par votre nom de domaine ou son adresse IP. Au début votre nom de domaine acheté n&#8217;est pas encore configuré. Il faut donc utiliser le nom de machine ( par exemple pour un VPS OVH: VPSxxxxxx.ovh.net ou pour un raspberry: raspberrypi.local ) ou votre adresse IP.</para>
</callout>
</calloutlist>
<simpara>ou utilisez putty si vous êtes sous Windows.</simpara>
</listitem>
<listitem>
<simpara>Tapez votre mot de passe s&#8217;il est demandé. Si vous avez installé une clé de connexion ce ne devrait pas être le cas.</simpara>
</listitem>
<listitem>
<simpara>Loguez-vous <literal>root</literal>. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">sudo bash</programlisting>
<simpara>Un mot de passe vous est demandé. Tapez le mot de passe demandé.</simpara>
</listitem>
<listitem>
<simpara>Dans le cas contraire (pas de sudo créé et connexion en root directe sur le serveur):</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Se loguer root sur le serveur distant. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh root@&lt;example.com&gt; <co xml:id="CO2-1"/></programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>remplacer ici &lt;example.com&gt; par votre nom de domaine.</para>
</callout>
</calloutlist>
<simpara>Tapez ensuite votre mot de passe root</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="pass_gen">
<title>Gestion des mots de passe</title>
<simpara>A propos des mots de passe: il est conseillé de saisir des mots de passe de 12 caractères contenant des majuscules/minuscules/nombres/caractères spéciaux. Une autre façon de faire est de saisir de longues phrases. Par exemple: 'J&#8217;aime manger de la mousse au chocolat parfumée à la menthe'. Ce dernier exemple a un taux de complexité bien meilleur qu&#8217;un mot de passe classique. Il est aussi plus facile à retenir que 'Az3~1ym_a&amp;'.</simpara>
<simpara>Cependant, si vous êtes en manque d&#8217;inspiration et que vous souhaitez générer des mots de passe, voici quelques méthodes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>En se basant sur la date. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">date +%s | sha256sum | base64 | head -c 32 ; echo <co xml:id="CO3-1"/></programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>remplacez 32 par la valeur qui vous convient pour générer un mot de passe d&#8217;une taille différente de 32 caractères</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>En se basant sur les nombres aléatoires système. Tapez l&#8217;une des deux lignes ci dessous :</simpara>
<programlisting language="bash" linenumbering="unnumbered">tr -cd '[:graph:]' &lt; /dev/urandom | head -c 32; echo <co xml:id="CO4-1"/>
tr -cd A-Za-z0-9 &lt; /dev/urandom | head -c 32;echo <co xml:id="CO4-2"/></programlisting>
<calloutlist>
<callout arearefs="CO4-1 CO4-2">
<para>remplacez 32 par la valeur qui vous convient pour générer un mot de passe d&#8217;une taille différente de 32 caractères</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>En utilisant Openssl. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">openssl rand -base64 32 | cut -c-32 <co xml:id="CO5-1"/></programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>remplacez 32 par la valeur qui vous convient pour générer un mot de passe d&#8217;une taille différente de 32 caractères</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>En utilisant gpg. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">gpg --gen-random --armor 1 32 | cut -c-32 <co xml:id="CO6-1"/></programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>remplacez 32 par la valeur qui vous convient pour générer un mot de passe d&#8217;une taille différente de 32 caractères</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>En utilisant pwgen pour générer des mots de passe qui suivent des règles de longueur et types de caractères.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Pour installer l&#8217;outil, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install pwgen</programlisting>
</listitem>
<listitem>
<simpara>Ensuite tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">pwgen -Bcny 32 -1 <co xml:id="CO7-1"/></programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>remplacez 32 par la valeur qui vous convient pour générer un mot de passe d&#8217;une taille différente de 32 caractères. La commande crée un mot de passe non ambigue avec au moins une majuscule , une valeur numérique, un symbole.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>En utilisant apg pour générer des mots de passe prononcables tel que: <literal>7quiGrikCod+ (SEVEN-qui-Grik-Cod-PLUS_SIGN)</literal></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Pour installer l&#8217;outil, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install apg</programlisting>
</listitem>
<listitem>
<simpara>Ensuite tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apg</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>En utilisant xkcdpass pour générer des passphrases comme: <literal>context smashup spiffy cuddly throttle landfall</literal></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Pour installer l&#8217;outil, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install xkcdpass</programlisting>
</listitem>
<listitem>
<simpara>Ensuite tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">xkcdpass</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_du_linux_sur_votre_raspberry_pi">
<title>Installation du linux sur votre Raspberry Pi</title>
<simpara>C&#8217;est la première étape.</simpara>
<simpara>Il vous faut bien choisir le type de linux que vous souhaitez installer:</simpara>
<itemizedlist>
<listitem>
<simpara>Debian 64: C&#8217;est la distribution la plus connue et celle qui offre le plus de possibilités juste après l&#8217;installation (notamment pour faire de la domotique, utiliser le GPIO &#8230;&#8203;) .</simpara>
</listitem>
<listitem>
<simpara>Ubuntu 64: Elle est plus proche d&#8217;une Ubuntu standard.</simpara>
</listitem>
</itemizedlist>
<simpara>Il vous faudra un lecteur de flash microSD - USB que vous brancherez sur votre PC.</simpara>
<simpara>Il existe maintenant un outil nommé <link xl:href="https://www.raspberrypi.org/downloads/">Rasberry PI Imager</link> pour la plateforme qui vous convient. C&#8217;est le moyen de plus simple de flasher votre Raspberry pi.</simpara>
<simpara>Pour Windows, très simple, il suffit de lancer le programme téléchargé.
Pour Linux, appliquer la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd /tmp
wget https://downloads.raspberrypi.org/imager/imager_amd64.deb
dpkg -i imager_amd64.deb</programlisting>
</listitem>
<listitem>
<simpara>Lancez le programme.</simpara>
</listitem>
</orderedlist>
<simpara>Suivez la procédure ci dessous commune à toutes les plateformes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Vous avez deux façons d&#8217;installer:</simpara>
<itemizedlist>
<listitem>
<simpara>avec un écran et un clavier qui est la méthode la plus facile</simpara>
</listitem>
<listitem>
<simpara>en mode Headless qui est plus complexe mais ne nécessite pas d&#8217;écran ni de clavier. L&#8217;installation s&#8217;effectue automatiquement.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Sélectionnez <literal>Choisir le modèle</literal> et dans la liste choisissez votre type de Raspberry</simpara>
</listitem>
<listitem>
<simpara>Sélectionnez <literal>Choisir l&#8217;OS</literal> et dans la liste choisissez <literal>Raspberry Pi OS (64-bit)</literal> ou <literal>Other general-purpose OS</literal>&#8594;`Ubuntu`&#8594;`Ubuntu Desktop 64`</simpara>
</listitem>
<listitem>
<simpara>Sélectionnez <literal>Choisir le Stockage</literal> et sélectionnez votre lecteur de carte SD</simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Suivant</literal></simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Modifier Réglages</literal> si vous souhaitez installer en mode headless le Raspberry sinon cliquez sur <literal>Non</literal> et allez à l&#8217;étape 10</simpara>
</listitem>
<listitem>
<simpara>Dans l&#8217;onglet <literal>Général</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Donnez le nom de votre Raspberry dans <literal>Nom d&#8217;hôte</literal></simpara>
</listitem>
<listitem>
<simpara>Donnez votre utilisateur sudo dans <literal>nom d&#8217;utilisateur</literal></simpara>
</listitem>
<listitem>
<simpara>Donnez votre mot de passe dans <literal>Mot de passe</literal>. Utilisez un générateur de mot de passe pour en obtenir un suffisamment complexe</simpara>
</listitem>
<listitem>
<simpara>Donnez votre SSID Wifi dans <literal>SSID</literal></simpara>
</listitem>
<listitem>
<simpara>Donner le mot de passe de votre wifi dans <literal>Mot de passe</literal>. Vous pouvez l&#8217;afficher si vous voulez vérifier que la saisie est correcte.</simpara>
</listitem>
<listitem>
<simpara>Dans <literal>Pays Wi-fi</literal> mettez <literal>FR</literal></simpara>
</listitem>
<listitem>
<simpara>Dans <literal>Fuseau horaire</literal> mettez votre pays <literal>Europe/Paris</literal> par exemple</simpara>
</listitem>
<listitem>
<simpara>Dans type de clavier mettez <literal>fr</literal> si vous avez un clavier Azerty</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Dans l&#8217;onglet `Services</simpara>
<itemizedlist>
<listitem>
<simpara>Activez <literal>Activer SSH</literal></simpara>
</listitem>
<listitem>
<simpara>Sélectionnez <literal>Utiliser un mot de passe pour l&#8217;authentification</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Enregistrer</literal></simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Oui</literal></simpara>
</listitem>
<listitem>
<simpara>Dans la fenêtre suivant intitulée <literal>Attention</literal> cliquez sur <literal>Oui</literal></simpara>
</listitem>
<listitem>
<simpara>Attendez la fin du chargement et de l&#8217;écriture sur la flash.</simpara>
</listitem>
<listitem>
<simpara>En fonction de la méthode choisie, allez au chapitre suivant ou celui encore après.</simpara>
</listitem>
</orderedlist>
<section xml:id="_installation_avec_écran_et_clavier">
<title>Installation avec écran et clavier</title>
<simpara>Pour ce type d&#8217;installation, il vous faut un clavier+souris et un écran.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Enlevez la carte SD de votre lecteur et insérez la dans votre raspberry PI.</simpara>
</listitem>
<listitem>
<simpara>Brancher un clavier, une souris et un écran (ou utilisez un écran 3,5" configuré selon la procédure en annexe).</simpara>
</listitem>
<listitem>
<simpara>Branchez votre Raspberry sur votre réseau Ethernet filaire (vous pouvez aussi utiliser le wifi)</simpara>
</listitem>
<listitem>
<simpara>Démarrez votre raspberry. Attention, les Raspberry PI 5 ont un bouton <literal>On</literal></simpara>
</listitem>
<listitem>
<simpara>Attendez environ 2 minutes le temps que le premier boot se termine. Tout pendant la procédure de boot, la petite led d&#8217;accès disque doit clignoter. Vous devez assez rapidement arriver sur le bureau</simpara>
</listitem>
<listitem>
<simpara>Un écran de configuration doit s&#8217;afficher automatiquement.</simpara>
</listitem>
<listitem>
<simpara>Sélectionnez le clavier et la langue en français</simpara>
</listitem>
<listitem>
<simpara>Tapez votre nouveau mot de passe et votre compte utilisateur</simpara>
</listitem>
<listitem>
<simpara>Choisissez votre connexion wifi et entrez le mot de passe</simpara>
</listitem>
<listitem>
<simpara>Les mises à jours de paquets Debian ainsi que l&#8217;installation des traductions en français vont s&#8217;installer.</simpara>
</listitem>
<listitem>
<simpara>Une fois les installations terminées, le Raspberry va rebooter.</simpara>
</listitem>
<listitem>
<simpara>Une fois rebooté, sélectionnez dans le menu <literal>Préférences</literal>&#8594;`Configuration du Raspberry PI`</simpara>
<itemizedlist>
<listitem>
<simpara>Dans l&#8217;onglet <literal>Display</literal> Cliquez sur <literal>Set Resolution</literal> et choisissez <literal>31: 1920x1080</literal></simpara>
</listitem>
<listitem>
<simpara>Dans l&#8217;onglet <literal>Interfaces</literal> activez <literal>SSH</literal> et <literal>VNC</literal></simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Valider</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Cliquez sur l’icône <literal>VNC</literal> dans la barre en haut à Droite</simpara>
<itemizedlist>
<listitem>
<simpara>Dans la fenêtre cliquez sur le menu burger en haut à Droite.</simpara>
</listitem>
<listitem>
<simpara>Choisissez <literal>Options</literal> puis l&#8217;onglet <literal>Sécurité</literal></simpara>
</listitem>
<listitem>
<simpara>Dans le champ Authentification choisissez l&#8217;option <literal>mot de passe VNC</literal></simpara>
</listitem>
<listitem>
<simpara>Tapez votre mot de passe dans les deux champs et cliquez <literal>Valider</literal> puis <literal>OK</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Vous pouvez maintenant rebooter votre Raspberry sans écran et sans clavier pour continuer la configuration.</simpara>
</listitem>
<listitem>
<simpara>Vous avez deux options: connexion en mode SSH ou au travers d&#8217;une connexion VNC</simpara>
</listitem>
</orderedlist>
<simpara>Allez au chapitre <xref linkend="_connexion_au_travers_du_réseau"/>.</simpara>
</section>
<section xml:id="_installation_headless">
<title>Installation Headless</title>
<simpara>Pour ce type d&#8217;installation, pas besoin d&#8217;écran, de clavier et de souris. Tout s&#8217;effectue à distance.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Enlevez la carte SD de votre lecteur et insérez la dans votre raspberry PI.</simpara>
</listitem>
<listitem>
<simpara>Démarrez votre raspberry. Attention, les Raspberry PI 5 ont un bouton <literal>On</literal></simpara>
</listitem>
<listitem>
<simpara>Attendez environ 2 minutes le temps que le premier boot se termine. Tout pendant la procédure de boot, la petite led d&#8217;accès disque doit clignoter.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_connexion_au_travers_du_réseau">
<title>Connexion au travers du réseau</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Vous devez maintenant découvrir l&#8217;adresse IP de votre Raspberry, pour cela tapez la commande suivante:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ping raspberrypi.local <co xml:id="CO8-1"/></programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para>Attention remplacez raspberrypi par le nom d&#8217;Hôte que vous avez choisi lors de la configuration</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Si le Raspberry a démarré correctement, cette commande doit montrer l&#8217;adresse IP du raspberry et une réponse correcte au ping</simpara>
</listitem>
</orderedlist>
<screen>PING raspberrypi.local (192.168.3.212) 56(84) bytes of data.
64 bytes from raspberrypi.local (192.168.3.212): icmp_seq=1 ttl=64 time=1.32 ms</screen>
<orderedlist numeration="arabic">
<listitem>
<simpara>Vous pouvez aussi utiliser la commande suivante:</simpara>
<programlisting language="bash" linenumbering="unnumbered"> arp -na | grep -Pi "(b8:27:eb)|(dc:a6:32)|(e4:5f:01)|(d8:3a:dd)"</programlisting>
</listitem>
<listitem>
<simpara>Elle vous donnera l&#8217;adresse IP de tous les raspberry de votre réseau et présents dans le cache ARP de votre PC.</simpara>
</listitem>
<listitem>
<simpara>Ensuite testez l&#8217;adresse ip trouvée</simpara>
<programlisting language="bash" linenumbering="unnumbered">ping 192.168.0.100 <co xml:id="CO9-1"/></programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para>mettez ici l&#8217;adresse IP qui a été découverte.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Si le Raspberry a démarré correctement, cette commande doit montrer l&#8217;adresse IP du raspberry et une réponse correcte au ping</simpara>
</listitem>
</orderedlist>
<screen>PING 192.168.0.100 (192.168.0.100) 56(84) bytes of data.
64 bytes from 192.168.0.100: icmp_seq=1 ttl=64 time=1.49 ms</screen>
<orderedlist numeration="arabic">
<listitem>
<simpara>Si vous n&#8217;obtenez aucun résultat essayer la commande <literal>nmap</literal> sur le subnet de votre réseau local</simpara>
<itemizedlist>
<listitem>
<simpara>On obtient l&#8217;adresse local du subnet en tapant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">hostname -I</programlisting>
</listitem>
<listitem>
<simpara>l&#8217;adresse IP de votre PC est affichée comme premier mot. Par exemple :`192.168.3.10`</simpara>
</listitem>
<listitem>
<simpara>le subnet se déduit de cette adresse en gardant les 3 premiers nombres (cas général de la plupart des utilisateurs).</simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">nmap -sn 192.168.3.0/24 <co xml:id="CO10-1"/></programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para>En suite à l&#8217;exemple de hostname reçu dans l&#8217;étape précéndente, nous avons remplacé le 10 à la fin de l&#8217;adresse IP par 0.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>la commande affiche alors les adresses IP et mac de toutes les machines présentes sur le réseau.</simpara>
</listitem>
<listitem>
<simpara>le Raspberry se reconnait par son nom de machine qui contient le terme <literal>raspberry</literal> ou par son adresse mac qui est reconnue du type <literal>Raspberry Pi Foundation</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>vous pouvez alors directement vous connecter. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh username@adresse_ip <co xml:id="CO11-1"/></programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>username est le <literal>nom d&#8217;utilisateur</literal> défini lors de la configuration. adresse_ip est l&#8217;adresse IP du Raspberry pi découverte précédemment ou raspberrypi.local ou <literal>nom d&#8217;hôte</literal>.local</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Se loguer avec le mot de passe défini pendant la configuration</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_headless_de_ubuntu_64">
<title>Installation Headless de Ubuntu 64</title>
<simpara>Pour ce type d&#8217;installation, pas besoin d&#8217;écran, de clavier et de souris. Tout s&#8217;effectue à distance.</simpara>
<simpara>Dans la suite, je suppose que vous possédez un PC fonctionnant avec un Linux (la procédure peut être adaptée pour une machine Windows en utilisant la ligne de commande et putty)</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Avant d&#8217;enlever votre flash SD du lecteur, appliquez la procédure ci après:</simpara>
<itemizedlist>
<listitem>
<simpara>Sur la flash, 2 partitions ont été crées. Montez la partition <literal>system-boot</literal></simpara>
</listitem>
<listitem>
<simpara>sur cette partition, editez le fichier <literal>network-config</literal> et éditez le avec un éditeur de text (Nano ou vi sous linux ou Notepad sous windows).</simpara>
</listitem>
<listitem>
<simpara>Mettez y le texte suivant:</simpara>
<screen linenumbering="unnumbered">version: 2
ethernets:
  eth0:
    dhcp4: true
    optional: true
wifis:
  wlan0:
    dhcp4: true
    optional: true
    access-points:
      YOURSSID: <co xml:id="CO12-1"/>
        password: "YOURPASSWORD" <co xml:id="CO12-2"/></screen>
<calloutlist>
<callout arearefs="CO12-1">
<para>remplacez <literal>YOURSSID</literal> par le nom SSID de votre wifi local</para>
</callout>
<callout arearefs="CO12-2">
<para>remplacez <literal>YOURPASSWORD</literal> par le mot de passe de votre wifi local</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>sauvez le fichier</simpara>
</listitem>
<listitem>
<simpara>démontez la partition</simpara>
</listitem>
<listitem>
<simpara>au boot sur la carte SD, le fichier sera recopié dans votre configuration et le réseau wifi sera ainsi accessible</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Enlevez la carte SD de votre lecteur et insérez la dans votre Raspberry PI.</simpara>
</listitem>
<listitem>
<simpara>Démarrez votre raspberry.</simpara>
</listitem>
<listitem>
<simpara>Attendez environ 2 minutes le temps que le premier boot se termine. Tout pendant la procédure de boot, la petite led d&#8217;accès disque doit clignoter.</simpara>
</listitem>
<listitem>
<simpara>Vous devez maintenant découvrir l&#8217;adresse IP de votre Raspberry, pour cela tapez la commande suivante:
+</simpara>
</listitem>
</orderedlist>
<screen> arp -na | grep -Pi "(b8:27:eb)|(dc:a6:32)|(e4:5f:01)|(d8:3a:dd)"</screen>
<orderedlist numeration="arabic">
<listitem>
<simpara>Ensuite testez l&#8217;adresse ip trouvée</simpara>
<programlisting language="bash" linenumbering="unnumbered">ping 192.168.0.100 <co xml:id="CO13-1"/></programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>mettez ici l&#8217;adresse IP qui a été découverte.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Si le Raspberry a démarré correctement, cette commande doit montrer l&#8217;adresse IP du raspberry et une réponse correcte au ping</simpara>
</listitem>
</orderedlist>
<screen>PING 192.168.0.100 (192.168.0.100) 56(84) bytes of data.
64 bytes from 192.168.0.100: icmp_seq=1 ttl=64 time=1.49 ms</screen>
<orderedlist numeration="arabic">
<listitem>
<simpara>Si vous n&#8217;obtenez aucun résultat essayer la commande <literal>nmap</literal> sur le subnet de votre réseau local</simpara>
<itemizedlist>
<listitem>
<simpara>On obtient l&#8217;adresse local du subnet en tapant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">hostname -I</programlisting>
</listitem>
<listitem>
<simpara>l&#8217;adresse IP de votre PC est affichée comme premier mot. Par exemple :`192.168.3.10`</simpara>
</listitem>
<listitem>
<simpara>le subnet se déduit de cette adresse en gardant les 3 premiers nombres (cas général de la plupart des utilisateurs).</simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">nmap -sn 192.168.3.0/24</programlisting>
</listitem>
<listitem>
<simpara>la commande affiche alors les adresses IP et mac de toutes les machines présentes sur le réseau.</simpara>
</listitem>
<listitem>
<simpara>le Raspberry se reconnait par son nom de machine qui contient le terme <literal>ubuntu</literal> ou par son adresse mac qui est reconnue du type <literal>Raspberry Pi Foundation</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>vous pouvez alors directement vous connecter. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh ubuntu@adresse_ip <co xml:id="CO14-1"/></programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>adresse_ip est l&#8217;adresse IP du Raspberry pi découverte précédemment</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Se loguer avec le mot de passe <literal>ubuntu</literal></simpara>
</listitem>
<listitem>
<simpara>Un nouveau mot de passe vous sera demandé puis vous serez déconnecté.</simpara>
</listitem>
<listitem>
<simpara>Reconnectez vous.</simpara>
</listitem>
<listitem>
<simpara>Installez la langue française. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install language-pack-fr manpages-fr</programlisting>
</listitem>
<listitem>
<simpara>Installer la locale qui vous plait. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">dpkg-reconfigure locales</programlisting>
</listitem>
<listitem>
<simpara>Choisissez votre langue locale. Par exemple: <literal>fr_FR.UTF-8</literal></simpara>
</listitem>
<listitem>
<simpara>Installer la la timezone qui vous plait. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">dpkg-reconfigure tzdata</programlisting>
</listitem>
<listitem>
<simpara>Choisissez votre Timezone. Par exemple: <literal>Europe/Paris</literal></simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_configuration_basique">
<title>Configuration basique</title>
<section xml:id="_mettre_léditeur_de_votre_choix">
<title>Mettre l&#8217;éditeur de votre choix</title>
<simpara>En fonction de vos préférences en terme d&#8217;éditeur, choisissez celui qui vous convient pour les outils utilisant un éditeur de façon automatique tels que <literal>crontab</literal>.</simpara>
<simpara>Pour les débutants, il est conseillé d&#8217;utiliser <literal>nano</literal> pour les utilisateurs avancés, vous pouvez utiliser <literal>vim</literal></simpara>
<simpara><link linkend="root_login">Loguez vous comme root </link>.</simpara>
<simpara>Si vous voulez installer <literal>vim</literal>, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install vim</programlisting>
<simpara>Pour Sélectionner votre éditeur par défaut, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">update-alternatives  --config editor</programlisting>
<simpara>choisissez le chiffre correspondant à Nano ou Vim.basic et quittez.</simpara>
</section>
<section xml:id="_installation_dun_repository_pour_etc">
<title>Installation d&#8217;un repository pour <literal>/etc</literal></title>
<simpara>Si vous souhaitez gérer en gestion de configuration le contenu de votre répertoire <literal>/etc</literal>, installez <literal>etckeeper</literal>.</simpara>
<simpara>Cette installation est optionnelle. Elle permet de garder dans un repository GIT toutes les modifications qui sont effectuées dans /etc soit par vous soit au moment de l&#8217;installation de paquets.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt update
apt install etckeeper</programlisting>
</listitem>
<listitem>
<simpara>Vous pouvez créer un repository privé dans le cloud pour stocker votre configuration de serveur (autre serveur privé de confiance ou repository privé  <literal>Gitlab</literal> ou <literal>Github</literal>).</simpara>
</listitem>
<listitem>
<simpara>Ajoutez ce repository distant. Pour <literal>Gitlab</literal> et <literal>Github</literal>, une fois le repository créé, demandez l&#8217;affichage de la commande git pour une communication en ssh. Tapez ensuite sur votre serveur :</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd /etc
git remote add origin git@github.com:username/etc_keeper.git <co xml:id="CO15-1"/></programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>remplacer l&#8217;url par celle qui correspond au chemin de votre repository</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>modifier le fichier de configuration de <literal>etckeeper</literal>. tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/etckeeper/etckeeper.conf</programlisting>
</listitem>
<listitem>
<simpara>Recherchez la ligne contenant <literal>PUSH_REMOTE</literal> et ajoutez y tous les repositories distant sur lesquels vous souhaitez pousser les modifications. Pour notre configuration, mettez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">PUSH_REMOTE="origin"</programlisting>
</listitem>
<listitem>
<simpara>Pour éviter des demandes de mot de passe de la part de <literal>github</literal> ou <literal>gitlab</literal>, il est nécessaire de déclarer une clé publique sur leur site. Créez une clé sur votre serveur pour l&#8217;utilisateur root:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Créer un répertoire <literal>/root/.ssh</literal> s&#8217;il n&#8217;existe pas. tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd /root
mkdir -p .ssh</programlisting>
</listitem>
<listitem>
<simpara>Allez dans le répertoire. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd /root/.ssh</programlisting>
</listitem>
<listitem>
<simpara>Générez vous clés. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh-keygen -t rsa</programlisting>
</listitem>
<listitem>
<simpara>Un ensemble de questions apparaît. Si un texte vous explique que le fichier existe déjà, arrêtez la procédure. Cela signifie que vous avez déjà créé une clé et que vous risquez de perdre la connexion à d&#8217;autres serveurs si vous en générez une nouvelle. Sinon, appuyez sur Entrée à chaque fois pour accepter les valeurs par défaut.</simpara>
</listitem>
<listitem>
<simpara>Allez sur <literal>gitlab</literal> ou <literal>github</literal> dans la rubriques "settings" et le menu "SSH keys". Ajoutez la clé que vous aurez affiché avec la commande suivante:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cat /root/.ssh/id_rsa.pub</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Effectuez un premier push. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd /etc
git push -u origin master</programlisting>
</listitem>
<listitem>
<simpara>aucun mot de passe ne doit vous être demandé. Si ce n&#8217;est pas le cas, re-vérifier les étapes précédentes.</simpara>
</listitem>
<listitem>
<simpara>Lancer <literal>etckeeper</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">etckeeper commit</programlisting>
</listitem>
<listitem>
<simpara>Tout le contenu de <literal>/etc</literal> est poussé sur le repository. Saisissez un commentaire.</simpara>
</listitem>
<listitem>
<simpara>C&#8217;est fait !</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_mise_à_jour_des_sources_de_paquets_debian_ou_ubuntu">
<title>Mise à jour des sources de paquets Debian ou Ubuntu</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Selon la distribution installée suivez la procédure ci-après ou celle suivante.</simpara>
</listitem>
<listitem>
<simpara>Modifier la liste standard de paquets Debian</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Éditer le fichier <literal>/etc/apt/sources.list</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/apt/sources.list</programlisting>
</listitem>
<listitem>
<simpara>Dé-commenter les lignes débutant par <literal>deb</literal> et contenant le terme <literal>backports</literal>. Par exemple pour <literal>#deb <link xl:href="http://deb.debian.org/debian">http://deb.debian.org/debian</link> bookworm-backports main contrib non-free</literal> enlever le # en début de ligne</simpara>
</listitem>
<listitem>
<simpara>Ajouter sur toutes les lignes les paquets <literal>contrib</literal> et <literal>non-free</literal> . en ajoutant ces textes après chaque mot <literal>main</literal> du fichier <literal>source.list</literal></simpara>
</listitem>
<listitem>
<simpara>Le fichier doit ressembler à ceci:</simpara>
<programlisting language="ini" linenumbering="unnumbered">deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware

## Major bug fix updates produced after the final release of the
## distribution.
deb http://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware
deb http://deb.debian.org/debian bookworm-updates main contrib non-free non-free-firmware

## N.B. software from this repository may not have been tested as
## extensively as that contained in the main release, although it includes
## newer versions of some applications which may provide useful features.
deb http://deb.debian.org/debian bookworm-backports main contrib non-free non-free-firmware</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Modifier la liste standard de paquets Ubuntu</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Éditer le fichier <literal>/etc/apt/sources.list</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/apt/sources.list</programlisting>
</listitem>
<listitem>
<simpara>Dé-commenter les lignes débutant par <literal>deb</literal> enlever le # en début de ligne</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Effectuer une mise à niveau du système</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Mettez à jour la liste des paquets. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt update</programlisting>
</listitem>
<listitem>
<simpara>Installez les nouveautés. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt dist-upgrade</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Effectuez du ménage. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt autoremove</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_des_paquets_de_base">
<title>Installation des paquets de base</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
</listitem>
</orderedlist>
<programlisting language="bash" linenumbering="unnumbered">apt install curl wget ntpdate apt-transport-https apt-listchanges apt-file apt-rdepends man</programlisting>
</section>
<section xml:id="_installer_loutil_debfoster">
<title>Installer l&#8217;outil Debfoster</title>
<simpara>L&#8217;outil <literal>debfoster</literal> permet de ne conserver que les paquets essentiels.</simpara>
<simpara>Cette installation est optionnelle.</simpara>
<simpara>Il maintient un fichier <literal>keepers</literal> présent dans <literal>/var/lib/debfoster</literal></simpara>
<simpara>En répondant aux questions de conservations de paquets, <literal>debfoster</literal> maintient la liste des paquets uniques nécessaires au système.
Tous les autres paquets seront supprimés.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Ajouter le paquet <literal>debfoster</literal>. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install debfoster</programlisting>
</listitem>
<listitem>
<simpara>Lancez <literal>debfoster</literal>. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">debfoster</programlisting>
</listitem>
<listitem>
<simpara>Répondez au questions pour chaque paquet</simpara>
</listitem>
<listitem>
<simpara>Acceptez la liste des modifications proposées à la fin. Les paquets superflus seront supprimés</simpara>
</listitem>
</orderedlist>
<simpara>Ci dessous une petite liste de paquets à conserver sur une installation basique Debian 64 pour Raspberry PI:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>apt-file</simpara></entry>
<entry align="left" valign="top"><simpara>apt-listchanges</simpara></entry>
<entry align="left" valign="top"><simpara>apt-rdepends</simpara></entry>
<entry align="left" valign="top"><simpara>apt-transport-https</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>avahi-daemon</simpara></entry>
<entry align="left" valign="top"><simpara>build-essential</simpara></entry>
<entry align="left" valign="top"><simpara>cifs-utils</simpara></entry>
<entry align="left" valign="top"><simpara>console-setup</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>crda</simpara></entry>
<entry align="left" valign="top"><simpara>debconf-utils</simpara></entry>
<entry align="left" valign="top"><simpara>debfoster</simpara></entry>
<entry align="left" valign="top"><simpara>dphys-swapfile</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>dselect</simpara></entry>
<entry align="left" valign="top"><simpara>ethtool</simpara></entry>
<entry align="left" valign="top"><simpara>fake-hwclock</simpara></entry>
<entry align="left" valign="top"><simpara>fbset</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>firmware-atheros</simpara></entry>
<entry align="left" valign="top"><simpara>firmware-brcm80211</simpara></entry>
<entry align="left" valign="top"><simpara>firmware-libertas</simpara></entry>
<entry align="left" valign="top"><simpara>firmware-misc-nonfree</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>firmware-realtek</simpara></entry>
<entry align="left" valign="top"><simpara>gdb</simpara></entry>
<entry align="left" valign="top"><simpara>hardlink</simpara></entry>
<entry align="left" valign="top"><simpara>htop</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>libpam-chksshpwd</simpara></entry>
<entry align="left" valign="top"><simpara>libraspberrypi-doc</simpara></entry>
<entry align="left" valign="top"><simpara>locales</simpara></entry>
<entry align="left" valign="top"><simpara>man-db</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>mkvtoolnix</simpara></entry>
<entry align="left" valign="top"><simpara>ncdu</simpara></entry>
<entry align="left" valign="top"><simpara>nfs-common</simpara></entry>
<entry align="left" valign="top"><simpara>ntpdate</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>p7zip-full</simpara></entry>
<entry align="left" valign="top"><simpara>pi-bluetooth</simpara></entry>
<entry align="left" valign="top"><simpara>pkg-config</simpara></entry>
<entry align="left" valign="top"><simpara>python-is-python3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>raspberrypi-net-mods</simpara></entry>
<entry align="left" valign="top"><simpara>raspinfo</simpara></entry>
<entry align="left" valign="top"><simpara>rng-tools</simpara></entry>
<entry align="left" valign="top"><simpara>rpi-update</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>rsync</simpara></entry>
<entry align="left" valign="top"><simpara>ssh</simpara></entry>
<entry align="left" valign="top"><simpara>ssh-import-id</simpara></entry>
<entry align="left" valign="top"><simpara>strace</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>sudo</simpara></entry>
<entry align="left" valign="top"><simpara>udisks2</simpara></entry>
<entry align="left" valign="top"><simpara>usb-modeswitch</simpara></entry>
<entry align="left" valign="top"><simpara>userconf-pi</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>v4l-utils</simpara></entry>
<entry align="left" valign="top"><simpara>wireless-tools</simpara></entry>
<entry align="left" valign="top"><simpara>wpasupplicant</simpara></entry>
<entry align="left" valign="top"><simpara>zip</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>La même liste pour un Ubuntu pour Raspberry PI:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>apt-file</simpara></entry>
<entry align="left" valign="top"><simpara>apt-listchanges</simpara></entry>
<entry align="left" valign="top"><simpara>apt-rdepends</simpara></entry>
<entry align="left" valign="top"><simpara>apt-transport-https</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>cloud-init</simpara></entry>
<entry align="left" valign="top"><simpara>debfoster</simpara></entry>
<entry align="left" valign="top"><simpara>etckeeper</simpara></entry>
<entry align="left" valign="top"><simpara>language-pack-fr</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>linux-firmware-raspi2</simpara></entry>
<entry align="left" valign="top"><simpara>linux-raspi</simpara></entry>
<entry align="left" valign="top"><simpara>manpages-fr</simpara></entry>
<entry align="left" valign="top"><simpara>ntpdate</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>openssh-server</simpara></entry>
<entry align="left" valign="top"><simpara>u-boot-rpi</simpara></entry>
<entry align="left" valign="top"><simpara>ubuntu-server</simpara></entry>
<entry align="left" valign="top"><simpara>ubuntu-standard</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>wpasupplicant</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_création_dun_fichier_keeper_dans_etc">
<title>Création d&#8217;un fichier keeper dans /etc</title>
<simpara>Vous pourriez être intéressé après l&#8217;installation de <literal>debfoster</literal> et de <literal>etckeeper</literal> de construire automatiquement un fichier qui contient la liste des paquets qui permettent de réinstaller le système:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/etckeeper/pre-commit.d/35debfoster</programlisting>
</listitem>
<listitem>
<simpara>Saisissez dans le fichier:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh
set -e

# Make sure sort always sorts in same order.
LANG=C
export LANG

shellquote() {
        # Single quotes text, escaping existing single quotes.
        sed -e "s/'/'\"'\"'/g" -e "s/^/'/" -e "s/$/'/"
}


if [ "$VCS" = git ] || [ "$VCS" = hg ] || [ "$VCS" = bzr ] || [ "$VCS" = darcs ]; then
        # Make sure the file is not readable by others, since it can leak
        # information about contents of non-readable directories in /etc.
        debfoster -q -k /etc/keepers
        chmod 600 /etc/keepers
        sed -i "1i\\# debfoster file" /etc/keepers
        sed -i "1i\\# Generated by etckeeper.  Do not edit."  /etc/keepers

        # stage the file as part of the current commit
        if [ "$VCS" = git ]; then
                # this will do nothing if the keepers file is unchanged.
                git add keepers
        fi
        # hg, bzr and darcs add not done, they will automatically
        # include the file in the current commit
fi</programlisting>
</listitem>
<listitem>
<simpara>Sauvez et tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 755 /etc/etckeeper/pre-commit.d/35debfoster</programlisting>
</listitem>
<listitem>
<simpara>Exécutez maintenant <literal>etckeeper</literal></simpara>
<programlisting language="bash" linenumbering="unnumbered">etckeeper commit</programlisting>
</listitem>
<listitem>
<simpara>Le fichier keepers est créé et sauvegardé automatiquement.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_des_mises_à_jours_automatiques">
<title>Installation des mises à jours automatiques</title>
<simpara>Si vous souhaitez installer automatiquement les paquets Debian de correction de bugs de sécurité, cette installation est pour vous.</simpara>
<simpara>Cette installation est optionnelle.</simpara>
<warning>
<simpara>L&#8217;installation automatique de paquets peut conduire dans certains cas
très rare à des dysfonctionnements du serveur. Il est important de
regarder périodiquement les logs d&#8217;installation.</simpara>
</warning>
<simpara>Suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install unattended-upgrades</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="domain_config">
<title>Vérification du nom de serveur</title>
<simpara>Cette partie consiste à vérifier que le serveur a un hostname correctement configuré.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>vérifier que le hostname est bien celui attendu (c&#8217;est à dire configuré par votre hébergeur). Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">cat /etc/hostname</programlisting>
<simpara>Le nom du hostname (sans le domaine) doit s&#8217;afficher.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Si ce n&#8217;est pas le cas, changer ce nom en éditant le fichier. Tapez :</simpara>
<programlisting language="shell" linenumbering="unnumbered">vi /etc/hostname</programlisting>
<simpara>Changez la valeur, sauvegardez et rebootez. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">reboot</programlisting>
</listitem>
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Vérifier le fichier <literal>hosts</literal>. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">cat /etc/hosts</programlisting>
<simpara>Si le fichier contient plusieurs lignes avec la même adresse de loopback en <literal>127.x.y.z</literal>, en gardez une seule et celle avec le hostname et le nom de domaine complet.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>si ce n&#8217;est pas le cas, changer les lignes en éditant le fichier. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/hosts</programlisting>
</listitem>
<listitem>
<simpara>Changez la ou les lignes, sauvegardez.</simpara>
<note>
<simpara>Le FQDN (nom de machine avec le nom de domaine) doit être déclaré avant le hostname simple dans le fichier <literal>hosts</literal>.  Pour que la configuration de votre serveur de mail soit correcte vous devez installer un FQDN contenant l&#8217;adresse de mail comme <literal>mail.example.com</literal></simpara>
</note>
</listitem>
<listitem>
<simpara>Rebootez. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">reboot</programlisting>
</listitem>
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Vérifiez que tout est correctement configuré.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">hostname</programlisting>
<simpara>La sortie doit afficher le nom de host.</simpara>
</listitem>
<listitem>
<simpara>Tapez ensuite :</simpara>
<programlisting language="bash" linenumbering="unnumbered">hostname -f</programlisting>
<simpara>La sortie doit afficher le nom de host avec le nom de domaine.</simpara>
</listitem>
<listitem>
<simpara>Reconfigurez les clés SSH server si vous avez changé le Hostname. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">rm -v /etc/ssh/ssh_host_*
dpkg-reconfigure openssh-server</programlisting>
</listitem>
<listitem>
<simpara>Les nouvelles clés vont être regénérées.</simpara>
</listitem>
<listitem>
<simpara>Déconnectez vous de votre session SSH et reconnectez vous.</simpara>
</listitem>
<listitem>
<simpara>Sur votre poste de travail, la clé d&#8217;authentification du serveur aura changée. il vous faudra annuler l&#8217;ancien puis accepter la nouvelle.</simpara>
</listitem>
<listitem>
<simpara>Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh-keygen -f "$HOME/.ssh/known_hosts" -R hostname <co xml:id="CO16-1"/></programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>remplacer hostname par l&#8217;adresse IP ou le nom de machine</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara><link linkend="root_login">Reloguez vous comme root sur le serveur</link></simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_interdire_le_login_direct_en_root">
<title>Interdire le login direct en root</title>
<simpara>Il est toujours vivement déconseillé d&#8217;autoriser la possibilité de se connecter directement en SSH en tant que root.</simpara>
<simpara>Avec les versions récentes de Debian Bookworm pour raspberry pi, il n&#8217;est plus nécessaire de créer le compte sudo qui est créé par défaut lors de la procédure d&#8217;installation standard. Cette procédure est cependant  indispensable pour l&#8217;installation d&#8217;une distribution debian standard.</simpara>
<simpara>Une remarque tout de même pour le raspberry pi: le compte sudo permet de se logger root sans aucun mot de passe. C&#8217;est considéré comme une faille de sécurité. Pour corriger cela, <link linkend="root_login">Loguez vous comme root sur le serveur</link> et tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">rm -f /etc/sudoers.d/010_pi-nopasswd</programlisting>
<simpara>La procédure suivante s&#8217;applique pour la création du compte sudo sur une debian standard.</simpara>
<simpara>Notre première action sera de désactiver le login direct en root  et d&#8217;autoriser le sudo.</simpara>
<simpara>Respectez bien les étapes de cette procédure:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Installez l&#8217;outil <literal>sudo</literal> s&#8217;il n&#8217;est pas déjà présent. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install sudo</programlisting>
</listitem>
<listitem>
<simpara>Ajoutez un utilisateur standard qui sera nommé par la suite en tant que &lt;sudo_username&gt;</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">adduser &lt;sudo_username&gt; <co xml:id="CO17-1"/></programlisting>
<calloutlist>
<callout arearefs="CO17-1">
<para>remplacer ici &lt;sudo_username&gt; par votre login</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Répondez aux questions qui vont sont posées: habituellement le nom complet d&#8217;utilisateur et le mot de passe.</simpara>
</listitem>
<listitem>
<simpara>Donner les attributs sudo à l&#8217;utilisateur <literal>&lt;sudo_username&gt;</literal>. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">usermod -a -G sudo &lt;sudo_username&gt; <co xml:id="CO18-1"/></programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>remplacer ici &lt;sudo_username&gt; par votre login</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Dans une autre fenêtre, se connecter sur le serveur avec votre nouveau compte <literal>&lt;sudo_username&gt;</literal>:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh &lt;sudo_username&gt;@&lt;example.com&gt; <co xml:id="CO19-1"/></programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para>remplacer ici &lt;sudo_username&gt; par votre login et &lt;example.com&gt; par votre nom de domaine</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>une fois logué, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">sudo bash</programlisting>
<simpara>Tapez le mot de passe de votre utilisateur. Vous devez avoir accès au compte root. Si ce n&#8217;est pas le cas, revérifiez la procédure et repassez toutes les étapes.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<important>
<simpara>Tout pendant que ces premières étapes ne donnent pas satisfaction ne passez pas à la suite sous peine de perdre la possibilité d’accéder à votre serveur.</simpara>
</important>
<orderedlist numeration="arabic">
<listitem>
<simpara>Il faut maintenant modifier la configuration de sshd.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Editez le fichier <literal>/etc/ssh/sshd_config</literal>, Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/ssh/sshd_config</programlisting>
<simpara>il faut rechercher la ligne: <literal>PermitRootLogin yes</literal> et la remplacer par:</simpara>
<programlisting language="ini" linenumbering="unnumbered">PermitRootLogin no</programlisting>
</listitem>
<listitem>
<simpara>Redémarrez le serveur ssh. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">service sshd restart</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Faites maintenant l&#8217;essai de vous re-loguer avec le compte root.Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh root@&lt;example.com&gt; <co xml:id="CO20-1"/></programlisting>
<calloutlist>
<callout arearefs="CO20-1">
<para>Remplacer ici &lt;example.com&gt; par votre nom de domaine</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Ce ne devrait plus être possible: le serveur vous l&#8217;indique par un message <literal>Permission denied, please try again.</literal></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_création_dune_clé_de_connexion_ssh_locale">
<title>Création d&#8217;une clé de connexion ssh locale</title>
<simpara>Pour créer une clé et la déployer:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Créez une clé sur votre machine locale (et pas sur le serveur distant!):</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Ouvrir un terminal</simpara>
</listitem>
<listitem>
<simpara>Créer un répertoire <literal>~/.ssh</literal> s&#8217;il n&#8217;existe pas. tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p $HOME/.ssh
chmod 700 ~/.ssh</programlisting>
</listitem>
<listitem>
<simpara>Allez dans le répertoire. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd ~/.ssh</programlisting>
</listitem>
<listitem>
<simpara>Générez vous clés. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh-keygen -t rsa</programlisting>
</listitem>
<listitem>
<simpara>Un ensemble de questions apparaît. Si un texte vous explique que le fichier existe déjà, arrêtez la procédure. Cela signifie que vous avez déjà créé une clé et que vous risquez de perdre la connexion à d&#8217;autres serveurs si vous en générez une nouvelle. Sinon, appuyez sur Entrée à chaque fois pour accepter les valeurs par défaut.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Sur votre PC local afficher la clé à l&#8217;écran. Elle sera copiée-collée par la suite:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cat ~/.ssh/id_rsa.pub</programlisting>
</listitem>
<listitem>
<simpara>Déployez votre clé:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Loguez vous sur votre serveur distant. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh &lt;sudo_username&gt;@&lt;example.com&gt; <co xml:id="CO21-1"/></programlisting>
<calloutlist>
<callout arearefs="CO21-1">
<para>remplacer ici &lt;sudo_username&gt; par votre login et &lt;example.com&gt; par votre nom de domaine</para>
</callout>
</calloutlist>
<simpara>Entrez votre mot de passe</simpara>
</listitem>
<listitem>
<simpara>Créer un répertoire <literal>~/.ssh</literal> s&#8217;il n&#8217;existe pas. tapez: :</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p $HOME/.ssh</programlisting>
</listitem>
<listitem>
<simpara>Éditez le fichier <literal>~/.ssh/authorized_keys</literal> tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi ~/.ssh/authorized_keys</programlisting>
<simpara>et coller dans ce fichier le texte contenu dans le votre fichier local <literal>~/.ssh/id_rsa.pub</literal>. Remarque: il peut y avoir déjà des clés dans le fichier <literal>authorized_keys</literal>.</simpara>
</listitem>
<listitem>
<simpara>Sécurisez votre fichier de clés. Tapez: :</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 600 ~/.ssh/authorized_keys</programlisting>
</listitem>
<listitem>
<simpara>Sécurisez le répertoire SSH; Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 700 ~/.ssh</programlisting>
</listitem>
<listitem>
<simpara>Déconnectez vous de votre session</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Vérifiez que tout fonctionne en vous connectant. Tapez: :</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh &lt;sudo_username&gt;@&lt;example.com&gt; <co xml:id="CO22-1"/></programlisting>
<calloutlist>
<callout arearefs="CO22-1">
<para>remplacer ici &lt;sudo_username&gt; par votre login et &lt;example.com&gt; par votre nom de domaine</para>
</callout>
</calloutlist>
<simpara>La session doit s&#8217;ouvrir sans demander de mot de passe.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_sudo_sans_mot_de_passe">
<title>Sudo sans mot de passe</title>
<simpara>Avant tout, il faut bien se rendre compte que cela constitue potentiellement une faille de sécurité et qu&#8217;en conséquence, le compte possédant cette propriété devra être autant sécurisé qu&#8217;un compte root.
L’intérêt étant d&#8217;interdire le compte root en connexion ssh tout en gardant la facilité de se loguer root sur le système au travers d&#8217;un super-compte.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Ajoutez un groupe sudonp et y affecter un utilisateur. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">addgroup --system sudonp</programlisting>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Ajouter l&#8217;utilisateur: :</simpara>
<programlisting language="bash" linenumbering="unnumbered">usermod -a -G sudonp &lt;sudo_username&gt;</programlisting>
</listitem>
<listitem>
<simpara>Éventuellement retirez l&#8217;utilisateur du groupe sudo s&#8217;il a été ajouté auparavant :</simpara>
<programlisting language="bash" linenumbering="unnumbered">gpasswd -d &lt;sudo_username&gt; sudo</programlisting>
</listitem>
<listitem>
<simpara>Éditez le fichier sudoers. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/sudoers.d/010_sudonp</programlisting>
</listitem>
<listitem>
<simpara>Ajouter dans le fichier la ligne suivante:</simpara>
<programlisting language="ini" linenumbering="unnumbered">%sudonp ALL=(ALL:ALL) NOPASSWD: ALL</programlisting>
<simpara>L&#8217;utilisateur nom_d_utilisateur pourra se logger root sans mot de passe au travers de la commande <literal>sudo bash</literal></simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_configuration_du_motd">
<title>Configuration du Motd</title>
<simpara>Le motd est affiché au moment ou l&#8217;utilisateur se loggue en ssh. Nous allons configurer l&#8217;affichage de plusieurs informations importantes.</simpara>
<section xml:id="_installation_de_neofetch">
<title>Installation de Neofetch</title>
<simpara>Neofetch affiche au démarrage de votre système des informations sur le fonctionnement de celui-ci.</simpara>
<simpara>Nous allons créer une configuration système:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Installez le package neofetch. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install neofetch</programlisting>
</listitem>
<listitem>
<simpara>Editez ensuite le fichier <literal>/etc/neofetch.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/neofetch.conf</programlisting>
</listitem>
<listitem>
<simpara>Mettez ensuite dans le fichier la configuration suivante:</simpara>
<programlisting language="bash" linenumbering="unnumbered">print_info() {
    info title
    info underline

    info "OS" distro
    info "Host" model
    info "Kernel" kernel
    info "Uptime" uptime
    info "Packages" packages
    info "Shell" shell
    info "Resolution" resolution
    info "DE" de
    info "WM" wm
    info "WM Theme" wm_theme
    info "Theme" theme
    info "Icons" icons
    info "Terminal" term
    info "Terminal Font" term_font
    info "CPU" cpu
    info "CPU Usage" cpu_usage
    prin "CPU Temp" "$(vcgencmd measure_temp | awk -F '=' '{print $2}')" <co xml:id="CO23-1"/>
    prin "Load" "$(cat /proc/loadavg | awk '{print $1, $2, $3}')"
    info "GPU" gpu
    info "GPU Driver" gpu_driver  # Linux/macOS only
    info "Memory" memory
    info "Disk" disk
    info "Local IP" local_ip
    info "Public IP" public_ip
    info "Users" users
    info "Locale" locale  # This only works on glibc systems.

    info cols
}

title_fqdn="on"
memory_percent="on"
memory_unit="mib"
package_managers="on"
image_backend="ascii"
cpu_temp="on"</programlisting>
<calloutlist>
<callout arearefs="CO23-1">
<para>Cette ligne est à retirer si vous n&#8217;utilisez pas de Raspberry PI 4 ou 5</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_configuration_du_motd_avec_neofetch">
<title>Configuration du MOTD avec Neofetch</title>
<simpara>Pour afficher les informations au moment du login ssh, vous devez modifier le fichier Motd:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Editez le fichier Neofetch du MOTD</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/update-motd.d/20-neofetch</programlisting>
</listitem>
<listitem>
<simpara>Mettez ensuite dans le fichier la configuration suivante:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh
neofetch --config /etc/neofetch.conf</programlisting>
</listitem>
<listitem>
<simpara>Changez les permissions du fichier <literal>20-neofetch</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 755 /etc/update-motd.d/20-neofetch</programlisting>
</listitem>
<listitem>
<simpara>A notez que vous pouvez utiliser Neofetch pour votre fichier <literal>.bash_profile</literal></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_mise_à_jour_de_packages">
<title>Mise à jour de packages</title>
<simpara>Vous pouvez ajouter la liste des mises à jours dans le fichier MOTD:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Installez le package python de gestion APT. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install python3-apt</programlisting>
</listitem>
<listitem>
<simpara>Editez le fichier MOTD</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/update-motd.d/30-updates</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier mettez le contenu suivant:</simpara>
<programlisting language="python" linenumbering="unnumbered">#!/usr/bin/python3
import sys
import subprocess
import apt_pkg

DISTRO = subprocess.Popen(["lsb_release", "-c", "-s"],
                          stdout=subprocess.PIPE).communicate()[0].strip()

class OpNullProgress(object):
    '''apt progress handler which supresses any output.'''
    def update(self):
        pass
    def done(self):
        pass

def is_security_upgrade(pkg):
    '''
    Checks to see if a package comes from a DISTRO-security source.
    '''
    security_package_sources = [("Ubuntu", "%s-security" % DISTRO),
                               ("Debian", "%s-security" % DISTRO)]

    for (file, index) in pkg.file_list:
        for origin, archive in security_package_sources:
            if (file.archive == archive and file.origin == origin):
                return True
    return False

# init apt and config
apt_pkg.init()

# open the apt cache
try:
    cache = apt_pkg.Cache(OpNullProgress())
except SystemError as e:
    sys.stderr.write("Error: Opening the cache (%s)" % e)
    sys.exit(-1)

# setup a DepCache instance to interact with the repo
depcache = apt_pkg.DepCache(cache)

# take into account apt policies
depcache.read_pinfile()

# initialise it
depcache.init()

# give up if packages are broken
if depcache.broken_count &gt; 0:
    sys.stderr.write("Error: Broken packages exist.")
    sys.exit(-1)

# mark possible packages
try:
    # run distro-upgrade
    depcache.upgrade(True)
    # reset if packages get marked as deleted -&gt; we don't want to break anything
    if depcache.del_count &gt; 0:
        depcache.init()

    # then a standard upgrade
    depcache.upgrade()
except SystemError as e:
    sys.stderr.write("Error: Couldn't mark the upgrade (%s)" % e)
    sys.exit(-1)

# run around the packages
upgrades = 0
security_upgrades = 0
for pkg in cache.packages:
    candidate = depcache.get_candidate_ver(pkg)
    current = pkg.current_ver

    # skip packages not marked as upgraded/installed
    if not (depcache.marked_install(pkg) or depcache.marked_upgrade(pkg)):
        continue

    # increment the upgrade counter
    upgrades += 1

    # keep another count for security upgrades
    if is_security_upgrade(candidate):
        security_upgrades += 1

    # double check for security upgrades masked by another package
    for version in pkg.version_list:
        if (current and apt_pkg.version_compare(version.ver_str, current.ver_str) &lt;= 0):
            continue
        if is_security_upgrade(version):
            security_upgrades += 1
            break

print("%d updates to install." % upgrades)
print("%d are security updates." % security_upgrades)
print("")  # leave a trailing blank line</programlisting>
</listitem>
<listitem>
<simpara>Changez les permissions du fichier <literal>30-updates</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 755 /etc/update-motd.d/30-updates</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_installer_loutil_dselect">
<title>Installer l&#8217;outil dselect</title>
<simpara>L&#8217;outil <literal>dselect</literal> permet de choisir de façon interactive les paquets que l&#8217;on souhaite installer.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Ajouter le paquet <literal>dselect</literal>. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install dselect</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="swap_create">
<title>Ajouter un fichier de swap</title>
<simpara>Pour un serveur VPS ou Raspberry Pi de 2 Go de RAM, la taille du fichier de swap sera de 2 Go.
Si vous avez beaucoup d&#8217;outils et de serveurs à installer il peut être nécessaire d&#8217;avoir 4 Go de RAM au total + 2 Go de swap.</simpara>
<simpara>Enfin pour un Raspberry PI 3 avec 1 Go de Ram, il faut ajouter 1 Go de swap.</simpara>
<simpara>Tapez :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tout d&#8217;abord, si l&#8217;outil <literal>dphys-swapfile</literal> est installé et configuré sur la machine, commencez par désactiver le swap. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">dphys-swapfile uninstall</programlisting>
</listitem>
<listitem>
<simpara>Pour installer un swap de 4Go, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd /
fallocate -l 4G /swapfile
chmod 600 /swapfile
mkswap /swapfile
swapon /swapfile</programlisting>
</listitem>
<listitem>
<simpara>Enfin ajoutez une entrée dans le fichier fstab. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/fstab</programlisting>
</listitem>
<listitem>
<simpara>Ajoutez la ligne:</simpara>
<screen>/swapfile swap swap defaults 0 0</screen>
</listitem>
<listitem>
<simpara>Enfin vous pouvez être tenté de limiter le swap (surtout utile sur les systèmes avec peu de RAM et du SSD. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/sysctl.conf</programlisting>
</listitem>
<listitem>
<simpara>Ajoutez ou modifiez la ligne:</simpara>
<screen>vm.swappiness = 5</screen>
</listitem>
<listitem>
<simpara>Le paramètre sera actif au prochain reboot</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_installation_initiale_des_outils">
<title>Installation initiale des outils</title>
<simpara>Les chapitres ci après décrivent l&#8217;installation des outils de base.</simpara>
<section xml:id="_supprimer_le_sleep_mode">
<title>Supprimer le sleep mode</title>
<simpara>Pour éviter que le raspberry ne s&#8217;endorme en raisons d&#8217;évènements sleep lancés par des programmes tiers (souvent du à la gestion d&#8217;économie d&#8217;énergie de XFCE), il est nécessaire de désactiver toute action de sleep.</simpara>
<simpara>Suivez la procédure ci-après:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target</programlisting>
</listitem>
<listitem>
<simpara>C&#8217;est fait !</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="xfce">
<title>Configuration de xfce et de l&#8217;environnement graphique</title>
<simpara>Ubuntu est installé avec un environnement graphique par défaut qui peut être considéré comme lourd pour un petit raspberry PI. vous pouvez installer à la place XFCE.</simpara>
<simpara>Il vous faut suivre la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Installez XFCE.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Pour Ubuntu, tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install xubuntu-desktop
apt remove --purge ubuntu-desktop
apt autoremove --purge</programlisting>
</listitem>
<listitem>
<simpara>Lorsque le système propose un système de login XWindows, choisissez Lightdm.</simpara>
</listitem>
<listitem>
<simpara>Pour Debian, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install xfce4 atril</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Pour avoir un autologin,</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>tapez pour Ubuntu :</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/lightdm/lightdm.conf.d/99-autologin.conf</programlisting>
</listitem>
<listitem>
<simpara>tapez pour Debian :</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/lightdm/lightdm.conf</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Dans le fichier ouvert, chercher <literal>Seat</literal> et tapez:</simpara>
<screen>[Seat:*]
autologin-user=[autologin account] <co xml:id="CO24-1"/>
autologin-user-timeout=0</screen>
<calloutlist>
<callout arearefs="CO24-1">
<para>mettez ici votre nom de compte en autologin</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Rebootez le système en n&#8217;oubliant pas de connecter un clavier et un écran.</simpara>
</listitem>
<listitem>
<simpara>le Window manager doit s&#8217;ouvrir loggué automatiquement</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_configuration_de_vnc">
<title>Configuration de VNC</title>
<simpara>VNC permet de prendre le contrôle à distance et en mode graphique du raspberry pi.</simpara>
<simpara>Il peut être lancé à la demande ou automatiquement au démarrage du raspberry pour un utilisateur standard.</simpara>
<simpara>L&#8217;installation est simple:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Sur le bureau du raspberry aller dans le menu &#8594;Préférences&#8594;Configuration du raspberry Pi</simpara>
</listitem>
<listitem>
<simpara>Dans la fenêtre qui s&#8217;ouvre allez dans l&#8217;onglet interfaces et cliquez sur VNC.</simpara>
</listitem>
<listitem>
<simpara>Cliquez sur Valider</simpara>
</listitem>
<listitem>
<simpara>Le raspberry PI a des problèmes de lenteurs lorsque vous ne branchez pas d&#8217;écran au moment du boot de votre raspberry. C&#8217;est typiquement le cas pour les configurations Headless. Pour corriger cela il faut forcer une résolution avec une autodétection de l&#8217;écran. Il faut modifier la conf de boot.</simpara>
</listitem>
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez,</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /boot/firmware/cmdline.txt</programlisting>
</listitem>
<listitem>
<simpara>Puis sur la ligne présenté à l&#8217;écran, ajoutez au bout le texte suivant précédé d&#8217;un espace. Vous pouvez changer la résolution (1024x768) comme vous voulez :</simpara>
<screen>video=HDMI-A-1:1024x768@60D</screen>
</listitem>
<listitem>
<simpara>Le driver graphique définit par défaut n&#8217;est pas le bon pour un Raspberry PI 4 ou 5. Tapez</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /boot/firmware/config.txt</programlisting>
</listitem>
<listitem>
<simpara>Cherchez la ligne <literal>dtoverlay=vc4-kms-v3d</literal> et replacez la avec :</simpara>
<screen>gpu_mem=128
dtoverlay=vc4-kms-v3d-pi4 <co xml:id="CO25-1"/>
hdmi_force_hotplug=1</screen>
<calloutlist>
<callout arearefs="CO25-1">
<para>pour un raspberry PI 5 remplacez -pi4 par -pi5.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Si la ligne n&#8217;est pas trouvé c&#8217;est que la configuration est plus récente. il faut alors rajouter ces lignes directement dans le fichier vers la fin.</simpara>
</listitem>
<listitem>
<simpara>Rebootez</simpara>
</listitem>
</orderedlist>
<simpara>Enfin sur votre machine Hôte:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Installez Tigervnc-viewer; c&#8217;est le seul qui est compatible avec les certificats de ce VNC</simpara>
</listitem>
<listitem>
<simpara>Sélectionnez l&#8217;adresse IP de votre raspberry</simpara>
</listitem>
<listitem>
<simpara>Connectez vous, acceptez les certificats</simpara>
</listitem>
<listitem>
<simpara>Entrez le login et mot de passe de votre compte sudo du raspberry.</simpara>
</listitem>
<listitem>
<simpara>C&#8217;est fait
Si vous ne souhaitez pas démarrer automatiquement x11vnc, ne créez pas le fichier 'vnc server.desktop' dans le répertoire autostart.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="hairpinning">
<title>Procédure spécifique pour les serveurs du réseau local</title>
<simpara>L&#8217;un des problèmes classiques des Routeurs internet est leur gestion du port forwarding lorsque l&#8217;on est sur un réseau local.</simpara>
<simpara>En effet la plupart des routeurs ne supportent pas un fonctionnalité appelée <literal>NAT loopback</literal> ou <literal>Hairpinning</literal>.</simpara>
<simpara>Le schéma ci dessous montre bien la problématique rencontrée sur un réseau local lorsque l&#8217;on utilise l&#8217;adresse DNS:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="essai.png"/>
</imageobject>
<textobject><phrase>essai</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Si vous avez configuré votre box pour que la machine 192.168.12.10 (sur votre réseau local) réponde aux requêtes venant d&#8217;internet au travers de la box, vous avez soit fait du port forwarding soit défini cette machine comme présente dans la DMZ du routeur Internet.</simpara>
<simpara>Si vous accèdez à votre nom de domaine <literal>home.example.com</literal> à partir d&#8217;internet, l&#8217;adresse IP qui sera fournie est la 20.10.3.5 pour l&#8217;exemple suivant. La configuration de votre routeur fera que les paquets IP seront retransmis vers votre Serveur Web qui répondra correctement aux requêtes.</simpara>
<simpara>Sur le réseau local, il en est autrement.</simpara>
<simpara>Lorsque depuis votre Home Server, vous demanderez la résolution de l&#8217;adresse <literal>home.example.com</literal>, c&#8217;est toujours l&#8217;adresse de 20.10.3.5 qui sera fournie (adresse IP fournie par le serveur DNS). La machine home Server (tout comme n&#8217;importe quel PC local) tentera de se connecter au routeur internet qui ne fera pas suivre les paquets vers le Server Web car la requête provient du réseau local interne et non pas d&#8217;internet.</simpara>
<simpara>De ce fait, il est impossible de contacter les services de <literal>home.example.com</literal> à partir du réseau local.</simpara>
<note>
<simpara>Certaines boxes plus récentes (ou d&#8217;autres très anciennes) ne sont pas soumises à ce problème et routent correctement les paquets. Faire une recherche <literal>ADSL Hairpinning</literal> sur google pour voir si votre box n&#8217;est pas soumise à ce problème.</simpara>
</note>
<section xml:id="_contournement_par_le_fichier_hosts">
<title>Contournement par le fichier Hosts</title>
<simpara>Un moyen de contourner cela est de définir dans le fichier <literal>/etc/hosts</literal> une entrée spécifique pour indiquer que <literal>home.example.com</literal> n&#8217;est pas 20.10.3.5 mais 192.168.12.10.</simpara>
<simpara>Appliquez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Editez le fichier hosts. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/hosts</programlisting>
</listitem>
<listitem>
<simpara>Allez à la fin du fichier et ajoutez dans le fichier:</simpara>
<screen>[Adresse IP locale]     [home.example.com] <co xml:id="CO26-1"/> <co xml:id="CO26-2"/>
[adresse IP locale]     [mail.example.com]</screen>
<calloutlist>
<callout arearefs="CO26-1">
<para>remplacez [Adresse IP locale] par l&#8217;adresse IP du serveur qui répond au domaine [home.example.com] dans votre réseau local. L&#8217;adresse IP doit être du type 192.x.y.z.</para>
</callout>
<callout arearefs="CO26-2">
<para>replacez [home.example.com] par votre nom de domaine</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_contournement_par_la_mise_en_place_dun_dns_interne">
<title>Contournement par la mise en place d&#8217;un DNS interne</title>
<simpara>Une autre manière de faire est de mettre en place un <link linkend="pihole">DNS interne</link>.
Il vous faudra au préalable l&#8217;installer (voir la doc du lien ci dessus).</simpara>
<simpara>Suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Loggez vous sur le serveur PI-Hole.</simpara>
</listitem>
<listitem>
<simpara>allez dans <literal>Local DNS</literal>&#8594;`DNS Records`</simpara>
</listitem>
<listitem>
<simpara>Dans le Champ domaine Ajouter votre domaine à redéfinir [home.example.com]</simpara>
</listitem>
<listitem>
<simpara>Dans le champ <literal>IP Address</literal> mettez l&#8217;adresse IP du serveur qui répond au domaine dans votre réseau local.</simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Add</literal></simpara>
</listitem>
</orderedlist>
<simpara>Le nom de domaine est maintenant correctement résolu sur le réseau local pour toute les machines qui récupèrent leurs paramètres avec le DHCP local.</simpara>
</section>
</section>
<section xml:id="_configuration_de_ssmtp">
<title>Configuration de ssmtp</title>
<simpara>Les mails locaux de la machine, notamment les mails envoyés sur le compte root doivent être relayés vers un serveur de messagerie.
La manière la plus simple lorsqu&#8217;un serveur n&#8217;a pas de nom de domaine internet est de faire suivre ces comptes mails vers une adresse mail externe.</simpara>
<section xml:id="_création_dun_mail_dédié">
<title>Création d&#8217;un mail dédié</title>
<simpara>Dans la suite du texte, "&lt;serveurmail&gt;" est le nom de la machine de relai de mail.</simpara>
<simpara>Pour créer une boite de messagerie dédiée à votre serveur:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Connectez vous sur l&#8217;interface ispconfig de votre serveur de mail qui relayera les mails de votre machine interne</simpara>
</listitem>
<listitem>
<simpara>Aller dans la rubrique <literal>Email</literal>. Sélectionnez ensuite le menu <literal>Email Mailbox</literal></simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Add new Mailbox</literal></simpara>
</listitem>
<listitem>
<simpara>Remplissez les champs suivants:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>Name:</literal> &#8592; mettez un descriptif de votre serveur</simpara>
</listitem>
<listitem>
<simpara><literal>`Email:</literal> &#8592; saisir le &lt;mailname&gt;@&lt;serveurmail&gt; . Par exemple <literal>homeserver@example.com</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Password:</literal> &#8592; <link linkend="pass_gen">Saisissez un mot de passe généré</link> ou générez en un en cliquant sur le bouton</simpara>
</listitem>
<listitem>
<simpara><literal>Repeat Password</literal> &#8592; saisissez une deuxième fois votre mot de passe</simpara>
</listitem>
<listitem>
<simpara><literal>Quota (0 for unlimited):</literal> &#8592; mettez éventuellement un quota ou laissez 0 pour illimité.</simpara>
</listitem>
<listitem>
<simpara><literal>Spamfilter:</literal> &#8592; Sélectionnez <literal>Normal</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Dans l’onglet Backup:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>Backup interval:</literal> Sélectionnez <literal>Daily</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Number of backup copies:</literal> Sélectionnez 1</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Save</literal></simpara>
</listitem>
</orderedlist>
<note>
<simpara>Notez que si vous créez une adresse mail nommée <literal>homeserver@example.com</literal>, vous pouvez utilisez toutes les variantes (nommées tag) derrière le caractère "+". Ainsi <literal>homeserver+nospam@example.com</literal> sera bien redirigé vers votre boite et l&#8217;extension <literal>+nospam</literal> vous permettre de trier automatiquement les mails selon leur catégorie.</simpara>
</note>
<note>
<simpara>Il est possible de changer ce caractère spécial en le modifiant dans le fichier <literal>/etc/postfix/main.cf</literal> sur la machine &lt;serveurmail&gt;.</simpara>
</note>
</section>
<section xml:id="_configuration_de_ssmtp_2">
<title>Configuration de ssmtp</title>
<simpara>Suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Installez le package ssmtp. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install ssmtp</programlisting>
</listitem>
<listitem>
<simpara>Editez ensuite le fichier <literal>/etc/ssmtp/ssmtp.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/ssmtp/ssmtp.conf</programlisting>
</listitem>
<listitem>
<simpara>Mettez ensuite dans le fichier la configuration suivante:</simpara>
<programlisting language="ini" linenumbering="unnumbered"># root is the person who gets all mail for userids &lt; 1000
root=&lt;mailname&gt;@&lt;servermail&gt; <co xml:id="CO27-1"/> <co xml:id="CO27-2"/>

# The place where the mail goes. The actual machine name is required no
# MX records are consulted. Commonly mailhosts are named mail.domain.com
mailhub=mail.&lt;serveurmail&gt;:465 <co xml:id="CO27-3"/>
UseTLS=YES
UseSTARTTLS=No
AuthUser=&lt;mailname&gt;@&lt;servermail&gt; <co xml:id="CO27-4"/> <co xml:id="CO27-5"/>
AuthPass=[mot_de_passe] <co xml:id="CO27-6"/>

# Where will the mail seem to come from?
rewriteDomain=&lt;servermail&gt; <co xml:id="CO27-7"/>

# The full hostname
hostname=&lt;serveurname&gt;.local <co xml:id="CO27-8"/></programlisting>
<calloutlist>
<callout arearefs="CO27-1 CO27-4 CO27-8">
<para>remplacer &lt;mailname&gt; par le nom de serveur défini au chapitre précédent</para>
</callout>
<callout arearefs="CO27-2 CO27-3 CO27-5 CO27-7">
<para>remplacer &lt;servermail&gt; par le nom de domaine du relai de mail.</para>
</callout>
<callout arearefs="CO27-6">
<para>remplacez [mot_de_passe] par le mot de passe généré au chapitre précédent.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Enfin dernier fichier à éditer, le fichier <literal>revaliases</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/ssmtp/revaliases</programlisting>
</listitem>
<listitem>
<simpara>Mettez ensuite dans le fichier la configuration suivante:</simpara>
<programlisting language="ini" linenumbering="unnumbered">root:&lt;mailname&gt;@&lt;serveurmail&gt;:mail.&lt;serveurmail&gt;:465 <co xml:id="CO28-1"/> <co xml:id="CO28-2"/></programlisting>
<calloutlist>
<callout arearefs="CO28-1">
<para>remplacer &lt;mailname&gt; par le nom de serveur défini au chapitre précédent</para>
</callout>
<callout arearefs="CO28-2">
<para>remplacer &lt;servermail&gt; par le nom de domaine du relai de mail.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="firewall">
<title>Déblocage de port de firewall</title>
<simpara>Par défaut, une fois le firewall activé, TOUS les ports sont bloqués en entrée de votre équipement. Cela veut dire qu&#8217;il ne sera pas possible de connecter une machine externe sur votre équipement sans avoir effectué une opération de déblocage du port du firewall.</simpara>
<simpara>Il existe deux manière de débloquer un port. Elle dépend de ce que vous avez configuré.</simpara>
<section xml:id="_déblocage_et_suppression_de_règles_de_firewall_avec_ispconfig">
<title>Déblocage et suppression de règles de Firewall avec ISPconfig</title>
<simpara>Appliquez les opérations suivantes pour Débloquez le firewall:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Allez sur le site ispconfig <link xl:href="https://example.com:8080/">https://example.com:8080/</link></simpara>
</listitem>
<listitem>
<simpara>Loguez-vous et cliquez sur la rubrique <literal>System</literal> et le menu <literal>Firewall</literal>. Cliquez sur votre serveur.</simpara>
</listitem>
<listitem>
<simpara>dans la rubrique <literal>Open TCP ports:</literal>, ajoutez le numero de port xxxx que vous souhaitez débloquer</simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>save</literal></simpara>
</listitem>
</orderedlist>
<simpara>Appliquez les opérations suivantes bloquer (en lever une règle de déblocage) de firewall:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Allez sur le site ispconfig <link xl:href="https://example.com:8080/">https://example.com:8080/</link></simpara>
</listitem>
<listitem>
<simpara>Loguez-vous et cliquez sur la rubrique <literal>System</literal> et le menu <literal>Firewall</literal>. Cliquez sur votre serveur.</simpara>
</listitem>
<listitem>
<simpara>dans la rubrique <literal>Open TCP ports:</literal>, Supprimer le port xxxx</simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>save</literal></simpara>
</listitem>
</orderedlist>
<simpara>Remarque: si vous utilisez VNC, il faut débloquer le port dans le firewall de ISPConfig. Appliquez la méthode de déblocage pour le port 5900.</simpara>
</section>
<section xml:id="_déblocage_de_firewall_ufw">
<title>Déblocage de Firewall UFW</title>
<important>
<simpara>Si vous avez installé ISPconfig vous ne devez pas utiliser cette méthode !</simpara>
</important>
<simpara>Tout d&#8217;abord, à la première utilisation, il vous faut appliquer la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Installez <literal>ufw</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install ufw</programlisting>
</listitem>
<listitem>
<simpara>Autorisez SSH si vous ne voulez pas perdre votre connexion SSH à l&#8217;activation du  firewall. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ufw allow 22/tcp
ufw allow 80/tcp
ufw allow 443/tcp
ufw allow 5900/tcp <co xml:id="CO29-1"/></programlisting>
<calloutlist>
<callout arearefs="CO29-1">
<para>Cette ligne autorise VNC et est utile si vous utilisez ce protocole sur votre Système. Il est fortement déconseillé pour un serveur visible sur internet d&#8217;autoriser ce protocole.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Activez le firewall. tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ufw enable</programlisting>
</listitem>
<listitem>
<simpara>C&#8217;est prêt !</simpara>
</listitem>
</orderedlist>
<simpara>Appliquez les opérations suivantes pour Débloquez le firewall:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ufw allow xxxx/tcp <co xml:id="CO30-1"/></programlisting>
<calloutlist>
<callout arearefs="CO30-1">
<para>remplacez xxxx par le numero de port que vous souhaitez débloquer</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<simpara>Appliquez les opérations suivantes bloquer (en lever une règle de déblocage) de firewall:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ufw delete allow xxxx/tcp <co xml:id="CO31-1"/></programlisting>
<calloutlist>
<callout arearefs="CO31-1">
<para>remplacez xxxx par le numero de port que vous souhaitez débloquer</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_configuration_de_avahi">
<title>Configuration de Avahi</title>
<simpara>Avahi est une mise en œuvre des protocoles Zeroconf (connexion au réseau avec zéro configuration) permettant ainsi à des logiciels de publier et de découvrir des services et des hôtes en cours d&#8217;exécution sur un réseau local TCP/IP sans configuration particulière. Par exemple, un utilisateur peut brancher son ordinateur sur un réseau et trouver instantanément des imprimantes pour imprimer, des fichiers à lire et des personnes à qui parler.</simpara>
<important>
<simpara>Avahi n&#8217;est à utiliser que sur un réseau local sécurisé. L&#8217;outil expose des informations qui peuvent compromettre des reseaux non sécurisés. Il est très fortement déconseillé d&#8217;utiliser Avahi sur un réseau public ou sur Internet.</simpara>
</important>
<simpara>Suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Installez le package <literal>avahi-daemon</literal>. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install avahi-daemon</programlisting>
</listitem>
<listitem>
<simpara>Configurez Avahi. Editez le fichier <literal>/etc/avahi/avahi-daemon.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/avahi/avahi-daemon.conf</programlisting>
</listitem>
<listitem>
<simpara>Inserez dans le fichier les infos suivantes:</simpara>
<programlisting language="ini" linenumbering="unnumbered">[server]
domain-name=local
use-ipv4=yes
use-ipv6=yes
enable-dbus=yes
ratelimit-interval-usec=1000000
ratelimit-burst=1000

[wide-area]
enable-wide-area=yes

[publish]
add-service-cookie=yes
publish-addresses=yes
publish-hinfo=yes
publish-workstation=yes
publish-domain=yes
publish-resolv-conf-dns-servers=yes

[reflector]
enable-reflector=yes

[rlimits]</programlisting>
</listitem>
<listitem>
<simpara>Redémarrez le service Avahi. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">service avahi-daemon restart</programlisting>
</listitem>
<listitem>
<simpara>Vérifiez que dans <literal>/etc/systemd/resolved.conf</literal>, le paramètre <literal>MulticastDNS=no</literal> n&#8217;est pas présent. Mettre yes sinon ou enlever la ligne.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="pihole">
<title>Configuration de Pi-Hole</title>
<simpara>Pi-hole a pour rôle de bloquer l&#8217;affichage des publicités sur toutes les machines connectées au niveau d&#8217;un réseau local. Il joue le rôle de serveur DNS local pour bloquer toutes les requêtes faites vers des domaines servant à afficher de la pub sur les sites que vous visitez.</simpara>
<simpara>Pi-hole fonctionne en se basant sur des listes de domaines malveillants et/ou connus pour servir à l&#8217;affichage de publicités. Concrètement, il faut configurer ses machines connectées avec l&#8217;adresse IP du Raspberry comme serveur DNS : au cours de notre navigation internet, toutes les requêtes sont envoyées vers Pi-hole, toutes celles qui pointent vers un site figurant dans une de ses listes de blocage seront bloquées, toutes les requêtes légitimes pourront passer et être soumises au serveur DNS public que vous choisirez d&#8217;utiliser dans les paramètres de Pi-hole.</simpara>
<simpara>Par conséquent, les sites web visités s&#8217;afficheront normalement mais les publicités éventuelles qu&#8217;ils contiennent ne s&#8217;afficheront plus.</simpara>
<simpara>Pihole offre d&#8217;autres fonctionnalités comme un serveur DHCP sur votre réseau local qui configurera les adresses IP de toute vos machines de façon statique ou dynamique selon le paramétrage.
Pihole fournit aussi la possibilité de résoudre le problème de &lt;#hairpinning, hairpinning&gt; en configurant de façon statique les nom DNS de vos serveurs sur votre réseau local.
Enfin dernier point, en configurant des DNS qui sont libres de censure et pas ceux de votre ISP, il vous sera possible d&#8217;accéder à des sites webs bloqués dans votre pays par décision politique.</simpara>
<section xml:id="_mettre_une_ip_statique">
<title>Mettre une IP statique</title>
<simpara>l&#8217;installation est très simple, suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/dhcpcd.conf</programlisting>
</listitem>
<listitem>
<simpara>Ajoutez à la fin du fichier le texte suivant:</simpara>
<programlisting language="ini" linenumbering="unnumbered">interface wlan0 <co xml:id="CO32-1"/>
        static ip_address=192.168.3.210/24 <co xml:id="CO32-2"/>
        static routers=192.168.3.254 <co xml:id="CO32-3"/>
        static domain_name_servers= 127.0.0.1</programlisting>
<calloutlist>
<callout arearefs="CO32-1">
<para>mettez ici l&#8217;interface concernée (eth0 ou wlan0)</para>
</callout>
<callout arearefs="CO32-2">
<para>Remplacez 192.168.3.210 par l&#8217;adresse IP statique de cette machine</para>
</callout>
<callout arearefs="CO32-3">
<para>Remplacez 192.168.3.254 par l&#8217;adresse IP de votre routeur internet (Box)</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_de_pi_hole">
<title>Installation de Pi-Hole</title>
<simpara>l&#8217;installation est très simple, suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">curl -sSL https://install.pi-hole.net | bash</programlisting>
</listitem>
<listitem>
<simpara>Laissez l&#8217;installation se faire, puis:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Cliquez sur <literal>Ok</literal> 2 fois de suite</simpara>
</listitem>
<listitem>
<simpara>Cliquez sur 'Oui' ensuite</simpara>
</listitem>
<listitem>
<simpara>Choisissez ensuite l&#8217;interface wlan0 (le wifi si vous etes en wifi) ou eth0 si vous êtes en filaire</simpara>
</listitem>
<listitem>
<simpara>Choisissez ensuite votre serveur DNS (quad9 filtered ECS DNSSEC)</simpara>
</listitem>
<listitem>
<simpara>Choisissez la liste de filtrage de StevenBlack</simpara>
</listitem>
<listitem>
<simpara>Installer l&#8217;interface web admin</simpara>
</listitem>
<listitem>
<simpara>Installer le serveur web lighttpd</simpara>
</listitem>
<listitem>
<simpara>Activer le log des requêtes</simpara>
</listitem>
<listitem>
<simpara>Choisissez "Show Everything" pour le "privacy mode FTL"</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>L&#8217;installation doit se terminer avec succès. Avant de cliquer sur OK notez bien le mot de passe. Vous le changerez ensuite.</simpara>
</listitem>
<listitem>
<simpara>Pour changer le mot de passe, Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">pihole -a -p</programlisting>
</listitem>
<listitem>
<simpara>Loguez vous sur votre site pihole en pointant sur <link xl:href="http://&lt;adresseIP&gt;/admin">http://&lt;adresseIP&gt;/admin</link>.</simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Login</literal>, tapez le mot de passe que vous avez noté et cliquez sur <literal>Log in</literal></simpara>
</listitem>
<listitem>
<simpara>Cliquez ensuite sur <literal>Settings</literal> &#8594; <literal>DHCP</literal> et configurez vos bails statique (static leases) en saisissant les adresses MAC, IP et les hostnames des machines</simpara>
</listitem>
<listitem>
<simpara>Allez ensuite dans <literal>Local DNS</literal> &#8594; <literal>DNS Records</literal> pour configurer les domaines et les adresses IP associées.</simpara>
</listitem>
<listitem>
<simpara>Si vous souhaitez bloquer des domaines vous pouvez ajouter un domaine avec une adresse IP en 0.0.0.0 ou ajouter un élément dans l&#8217;onglet blacklist</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_installation_dun_serveur_de_fichier_windows">
<title>Installation d&#8217;un serveur de fichier Windows</title>
<simpara>Le partage de fichier sous Linux s&#8217;appuie sur le logiciel Samba qui implémente les protocoles de Microsoft de partage des fichiers.</simpara>
<simpara>Deux configurations sont proposées dans ce tutoriel :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>une première avec un partage de fichier simple et peu sécurisé</simpara>
</listitem>
<listitem>
<simpara>une deuxième avec un serveur Active directory et un contrôleur de domaine.</simpara>
</listitem>
</orderedlist>
<simpara>Tout d&#8217;abord, il vous faudra installer Samba:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install samba</programlisting>
</listitem>
<listitem>
<simpara>Une première configuration de base sera installée. Elle sera à modifier en fonction de vos besoins.</simpara>
</listitem>
</orderedlist>
<section xml:id="_installation_dun_partage_de_fichier_basique">
<title>Installation d&#8217;un partage de fichier basique</title>
<simpara>Nous allons configurer un partage Samba à l&#8217;aide d&#8217;un serveur autonome. Dans le fichier nous allons configurer un partage du home, et d&#8217;un répertoire de partage public sur le réseau local en lecture écriture :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Editez le fichier <literal>smb.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/samba/smb.conf</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier remplacez tout le texte par:</simpara>
<programlisting language="ini" linenumbering="unnumbered">[global]
workgroup = HOME
server string = Samba Server %v
server role = standalone server
obey pam restrictions = yes
unix password sync = yes
passwd program = /usr/bin/passwd %u
passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .
pam password change = yes
map to guest = bad user
name resolve order = bcast host
dns proxy = no
usershare allow guests = yes


[homes]
   comment = Home Directories
   browseable = no
   read only = no
   create mask = 0700
   directory mask = 0700
   valid users = %S

[printers]
   comment = All Printers
   browseable = no
   path = /var/spool/samba
   printable = yes
   guest ok = no
   read only = yes
   create mask = 0700

[Public]
   comment = Public File Share
   path = /srv/samba/share
   browsable = yes
   writable = yes
   guest ok = yes
   read only = no
   create mode = 0777
   directory mode = 0777
   force user = public_user <co xml:id="CO33-1"/>
   force group = public_group <co xml:id="CO33-2"/></programlisting>
<calloutlist>
<callout arearefs="CO33-1">
<para>mettez ici le username de votre Linux qui possédera tous les fichiers.</para>
</callout>
<callout arearefs="CO33-2">
<para>mettez ici le groupname de votre linux qui possédera tous les fichiers.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Redémarrez Samba. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">service smbd restart
service nmbd restart</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_dun_serveur_active_directory_domain_controller">
<title>Installation d&#8217;un serveur Active Directory Domain Controller</title>
<simpara>Ici nous nous attaquons à une configuration nettement plus complexe qui consiste à mettre en place un serveur active directory basé sur Kerberos et un contrôleur de domaine en Active Directory qui sera muni ensuite de partage de fichiers contrôlés pas les droits des utilisateurs du domaine:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tout d&#8217;abord, il faut déclarer le nom de host du DC. Editez le fichier <literal>/etc/hosts</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/hosts</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier ajoutez sur l&#8217;adresse IP de votre machine, le nom du DC :</simpara>
<programlisting language="ini" linenumbering="unnumbered">[ip_address] dc1.home.lan dc1 <co xml:id="CO34-1"/></programlisting>
<calloutlist>
<callout arearefs="CO34-1">
<para>remplacez <literal>ip_address</literal> par l&#8217;adresse IP de votre machine</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Installez Samba DC. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install -y acl attr samba samba-dsdb-modules samba-vfs-modules smbclient winbind libpam-winbind libnss-winbind libpam-krb5 krb5-config krb5-user</programlisting>
</listitem>
<listitem>
<simpara>Reconfigurez Samba pour activer la version DC. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">systemctl disable --now smbd nmbd winbind
systemctl unmask samba-ad-dc
systemctl enable samba-ad-dc
mv /etc/samba/smb.conf /etc/samba/smb.conf.orig</programlisting>
</listitem>
<listitem>
<simpara>Provisionnez votre domaine. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">samba-tool domain provision</programlisting>
</listitem>
<listitem>
<simpara>Répondez aux questions suivantes:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>Realm</literal> &#8594; inscrivez votre réseau en majuscules (<literal>HOME.LAN</literal> par exemple). ne pas choisir <literal>LOCAL</literal> qui est déjà utilisé par <literal>Avahi</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>Domain</literal> &#8594; acceptez la valeur par défaut</simpara>
</listitem>
<listitem>
<simpara><literal>Server Role</literal>&#8594; Laisser la valeur par défaut</simpara>
</listitem>
<listitem>
<simpara><literal>Dns Backend</literal> &#8594; garder la valeur par défault</simpara>
</listitem>
<listitem>
<simpara><literal>Dns forwarder</literal> &#8594; laissez la valeur par défaut ou 127.0.1.1 si vous utilisez <literal>dnsmasq</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Administrator Password</literal> &#8594; tapez votre mot de passe administrateur</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Editez le fichier <literal>/etc/samba/smb.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/samba/smb.conf</programlisting>
</listitem>
<listitem>
<simpara>Dans ce fichier, Vérifiez que les informations suivantes sont présentes. Ajoutez les sinon :</simpara>
<programlisting language="bash" linenumbering="unnumbered"># Global parameters
[global]
        dns forwarder = [IP_DNS] <co xml:id="CO35-1"/>
        netbios name = DC
        realm = HOME.LAN <co xml:id="CO35-2"/>
        server role = active directory domain controller
        workgroup = HOME <co xml:id="CO35-3"/>
        interfaces = wlan0 eth0 lo
        bind interfaces only = yes
        template shell = /bin/bash
        template homedir = /home/%U

[sysvol]
        path = /var/lib/samba/sysvol
        read only = No

[netlogon]
        path = /var/lib/samba/sysvol/home.lan/scripts
        read only = No

[homes]
   comment = Home Directories
   browseable = no
   read only = no
   create mask = 0700
   directory mask = 0700
   valid users = %S

[printers]
   comment = All Printers
   browseable = no
   path = /var/spool/samba
   printable = yes
   guest ok = no
   read only = yes
   create mask = 0700

[Public]
   comment = Public File Share
   path = /srv/samba/share
   browsable = yes
   writable = yes
   guest ok = yes
   read only = no
   create mode = 0777
   directory mode = 0777
   force user = public_user <co xml:id="CO35-4"/>
   force group = public_group <co xml:id="CO35-5"/></programlisting>
<calloutlist>
<callout arearefs="CO35-1">
<para>remplacez <literal>IP_DNS</literal> par 127.0.0.1. Si vous décidez d&#8217;utiliser le DC de samba conjointement avec <literal>dnsmasq</literal>, vous devez mettre 127.0.1.1. voir plus bas pour le reste de la configuration.</para>
</callout>
<callout arearefs="CO35-2">
<para>ici vous retrouvez le Realm configuré plus haut</para>
</callout>
<callout arearefs="CO35-3">
<para>et le domaine configuré plus haut.</para>
</callout>
<callout arearefs="CO35-4">
<para>mettez ici le username de votre Linux qui possédera tous les fichiers.</para>
</callout>
<callout arearefs="CO35-5">
<para>mettez ici le groupname de votre linux qui possédera tous les fichiers.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Configurez la synchronisation temporelle (voir plus bas)</simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mv /etc/krb5.conf /etc/krb5.conf.orig
cp /var/lib/samba/private/krb5.conf /etc/krb5.conf</programlisting>
</listitem>
<listitem>
<simpara>Démarrez <literal>Samba</literal>. tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">systemctl restart samba-ad-dc
systemctl status samba-ad-dc</programlisting>
</listitem>
<listitem>
<simpara>Activez winbind dans le NSS. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/nsswitch.conf</programlisting>
</listitem>
<listitem>
<simpara>Puis dans le fichier changez les lignes suivantes:</simpara>
<programlisting language="ini" linenumbering="unnumbered">passwd: files winbind
group:  files winbind</programlisting>
</listitem>
<listitem>
<simpara>Vérification des résolutions d&#8217;hotes. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">host -t A home.lan <co xml:id="CO36-1"/>
host -t SRV _kerberos._udp.home.lan <co xml:id="CO36-2"/>
host -t SRV _ldap._tcp.home.lan <co xml:id="CO36-3"/></programlisting>
<calloutlist>
<callout arearefs="CO36-1 CO36-2 CO36-3">
<para>remplacez home.lan par votre nom de realm configuré plus haut.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>En résultat les trois commandes host doivent envoyer une résolution correcte.</simpara>
</listitem>
<listitem>
<simpara>Vérifier que samba est actif et que les partages sysvol et netlogin sont corrects. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">smbclient -L home.lan -N</programlisting>
</listitem>
<listitem>
<simpara>Vous devez voir au moins les deux partages listés.</simpara>
</listitem>
<listitem>
<simpara>Créez une zone de recherche inversée. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">samba-tool dns zonecreate DC1 1.27.172.in-addr.arpa --username=administrator <co xml:id="CO37-1"/> <co xml:id="CO37-2"/> <co xml:id="CO37-3"/></programlisting>
<calloutlist>
<callout arearefs="CO37-1">
<para>DC1 : Nom de votre serveur</para>
</callout>
<callout arearefs="CO37-2">
<para>1.27.172.in-addr.arpa : Adresse du sous réseau inversée. (Le sous réseau était 172.27.1.0. A remplacer par celui de votre réseau réel).</para>
</callout>
<callout arearefs="CO37-3">
<para>username : Compte ayant l’autorisation de créer la zone. Un mot de passe sera demandé.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Maintenant vous devez vous authentifier sur Kerberos avec le login <literal>administrator</literal>. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">kinit administrator@HOME.LAN <co xml:id="CO38-1"/></programlisting>
<calloutlist>
<callout arearefs="CO38-1">
<para>remplacez home.lan par votre nom de realm configuré plus haut.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Tapez ensuite votre mot de passe administrateur.</simpara>
</listitem>
<listitem>
<simpara>Changez l&#8217;expiration du mot de passe. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">samba-tool user setexpiry administrator --noexpiry</programlisting>
</listitem>
<listitem>
<simpara>Ajoutez des utilisateurs. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">samba-tool user create user1 user1_password <co xml:id="CO39-1"/>
samba-tool user setexpiry user1 --noexpiry <co xml:id="CO39-2"/></programlisting>
<calloutlist>
<callout arearefs="CO39-1 CO39-2">
<para>remplacer <literal>user1</literal> par votre nom de nouvel utilisateur et <literal>user1_password</literal> par son mot de passe.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Après avoir ajouté tous vos utilisateurs vous pouvez lister ceux configurés. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">samba-tool user list</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_mise_en_place_dun_serveur_membre_du_domaine">
<title>Mise en place d&#8217;un serveur membre du domaine</title>
<simpara>Cette procédure explique comme ajouter un serveur membre du domaine.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Normalement, le serveur DHCP s&#8217;il est configuré correctement doit configurer le serveur DNS du membre de domaine. Si ce n&#8217;est pas le cas il faudra appliquer la procédure ci après :</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>editez le fichier <literal>/etc/resolv.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/resolv.conf</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier, Insérez :</simpara>
<programlisting language="ini" linenumbering="unnumbered">nameserver [Adresse_ip] <co xml:id="CO40-1"/>
search home.lan <co xml:id="CO40-2"/></programlisting>
<calloutlist>
<callout arearefs="CO40-1">
<para>remplacez Adresse_ip par l&#8217;adresse IP de votre DC</para>
</callout>
<callout arearefs="CO40-2">
<para>indiquer ici le nom de domaine de votre realm (en minuscules)</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Installez Samba. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install -y acl attr samba samba-dsdb-modules samba-vfs-modules smbclient winbind libpam-winbind libnss-winbind libpam-krb5 krb5-config krb5-user</programlisting>
</listitem>
<listitem>
<simpara>Configurez Kerberos. tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/krb5.conf</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier insérez les lignes suivantes:</simpara>
<programlisting language="bash" linenumbering="unnumbered">[libdefaults]
	default_realm = HOME.LAN
	dns_lookup_realm = false
	dns_lookup_kdc = true</programlisting>
</listitem>
<listitem>
<simpara>Configurez la synchronisation temporelle (voir plus bas)</simpara>
</listitem>
<listitem>
<simpara>Editez le fichier <literal>/etc/samba/smb.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/samba/smb.conf</programlisting>
</listitem>
<listitem>
<simpara>Dans ce fichier, Vérifiez que les informations suivantes sont présentes. Ajoutez les sinon :</simpara>
<programlisting language="ini" linenumbering="unnumbered"># Global parameters
[global]
        security = ADS
        realm = HOME.LAN <co xml:id="CO41-1"/>
        workgroup = HOME <co xml:id="CO41-2"/>
        interfaces = wlan0 eth0 lo
        bind interfaces only = yes
        username map = /etc/samba/user.map
[printers]
   comment = All Printers
   browseable = no
   path = /var/spool/samba
   printable = yes
   guest ok = no
   read only = yes
   create mask = 0700

[Public]
   comment = Public File Share
   path = /srv/samba/share
   browsable = yes
   writable = yes
   guest ok = yes
   read only = no
   create mode = 0777
   directory mode = 0777
   force user = public_user <co xml:id="CO41-3"/>
   force group = public_group <co xml:id="CO41-4"/></programlisting>
<calloutlist>
<callout arearefs="CO41-1">
<para>remplacez HOME.LAN par le Realm configuré plus haut.</para>
</callout>
<callout arearefs="CO41-2">
<para>et le domaine configuré plus haut.</para>
</callout>
<callout arearefs="CO41-3">
<para>mettez ici le username de votre Linux qui possédera tous les fichiers.</para>
</callout>
<callout arearefs="CO41-4">
<para>mettez ici le groupname de votre linux qui possédera tous les fichiers.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Créez le fichier <literal>user.map</literal> afin de mapper l&#8217;utilisateur Linux Root sur le compte Windows Administrateur. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/samba/user.map</programlisting>
</listitem>
<listitem>
<simpara>Insérez dans ce fichier ceci:</simpara>
<programlisting language="ini" linenumbering="unnumbered">!root = HOME\Administrator <co xml:id="CO42-1"/></programlisting>
<calloutlist>
<callout arearefs="CO42-1">
<para>remplacez HOME par le domaine configuré plus haut</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Joignez le domaine. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">samba-tool domain join home.lan MEMBER -U administrator <co xml:id="CO43-1"/></programlisting>
<calloutlist>
<callout arearefs="CO43-1">
<para>remplacez home.lan par le Realm configuré plus haut.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Après avoir tapé votre mot de passe, <literal>samba</literal> indiquez que vous avez joint le domaine.</simpara>
</listitem>
<listitem>
<simpara>Activez winbind dans le NSS. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/nsswitch.conf</programlisting>
</listitem>
<listitem>
<simpara>Puis dans le fichier changez les lignes suivantes:</simpara>
<programlisting language="ini" linenumbering="unnumbered">passwd: files winbind
group:  files winbind</programlisting>
</listitem>
<listitem>
<simpara>redémarrez les services Samba. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">service smbd restart
service nmbd restart
service winbindd restart</programlisting>
</listitem>
<listitem>
<simpara>Testez winbindd. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">wbinfo --ping-dc</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_mise_en_place_dune_synchronisation_temporelle_du_serveur">
<title>Mise en place d&#8217;une synchronisation temporelle du serveur</title>
<simpara>Pour que samba avec un DC fonctionne correctement, il faut que le serveur soit correctement synchronisé.
A noter qu&#8217;il est bien d&#8217;une manière générale de synchroniser les serveurs.</simpara>
<simpara>Cette procédure est à appliquer sur le DC et sur le membre du domaine :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Installez chrony. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install chrony</programlisting>
</listitem>
<listitem>
<simpara>Configurez <literal>chrony</literal> pour fonctionner avec <literal>kerberos</literal>. tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chown root:_chrony /var/lib/samba/ntp_signd/
chmod 750 /var/lib/samba/ntp_signd/</programlisting>
</listitem>
<listitem>
<simpara>Editez le fichier <literal>chrony.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/chrony/chrony.conf</programlisting>
</listitem>
<listitem>
<simpara>Insérez ou modifier dans les fichiers les lignes pour avoir:</simpara>
<programlisting language="bash" linenumbering="unnumbered"># bind the chrony service to IP address of the Samba AD
bindcmdaddress [adresse_ip] <co xml:id="CO44-1"/>
# allow clients on the network to connect to the Chrony NTP server
allow [subnet]/24 <co xml:id="CO44-2"/>

# specify the ntpsigndsocket directory for the Samba AD
ntpsigndsocket /var/lib/samba/ntp_signd</programlisting>
<calloutlist>
<callout arearefs="CO44-1">
<para>mettez ici l&#8217;adresse IP de l' AD de votre serveur samba</para>
</callout>
<callout arearefs="CO44-2">
<para>mettez ici l&#8217;adresse du sous réseau.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Redémarrez <literal>chrony</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">systemctl restart chronyd
systemctl status chronyd</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_configuration_avec_dnsmasq_ou_pi_hole">
<title>Configuration avec DNSMASQ ou PI-HOLE</title>
<simpara>L&#8217;utilisation avec DNSMASQ ou PI-HOLE est tout à fait possible</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Editez le fichier <literal>07-dhcp-options.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/samba/smb.conf</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier ajoutez dans la section <literal>[global]</literal> la ligne suivante:</simpara>
<programlisting language="ini" linenumbering="unnumbered">        dns forwarder = [IP_DNS] <co xml:id="CO45-1"/></programlisting>
<calloutlist>
<callout arearefs="CO45-1">
<para>remplacez <literal>IP_DNS</literal> par 127.0.1.1.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Ajoutez ensuite une règle de forwarding de firewall. Editez le fichier <literal>iptables.up.rules</literal></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/iptables.up.rules</programlisting>
</listitem>
<listitem>
<simpara>Inserez à la fin du fichier la ligne suivante:</simpara>
<programlisting language="bash" linenumbering="unnumbered">-A OUTPUT -d 127.0.1.1/32 -p udp -m udp --dport 53 -j DNAT --to-destination 127.0.0.1:5353</programlisting>
</listitem>
<listitem>
<simpara>Créez une interface de loopback.</simpara>
</listitem>
<listitem>
<simpara>Editez <literal>/etc/network/interfaces.d/lo1</literal></simpara>
<programlisting language="bash" linenumbering="unnumbered"># loopback dns
auto lo:0
   iface lo:0 inet static
   address 127.0.1.1</programlisting>
</listitem>
<listitem>
<simpara>Tapez ensuite:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ufw allow 53/udp</programlisting>
</listitem>
<listitem>
<simpara>Rebooter votre serveur. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">reboot</programlisting>
<simpara>=== Modification de la configuration DHCP DNSMASQ</simpara>
</listitem>
</orderedlist>
<simpara>Si vous utilisez <literal>DHCP</literal> ou <literal>DNSMASQ</literal>, il est nécessaire de modifier la configuration du <literal>DHCP</literal> pour que les informations sur le serveur de fichier soit correctement diffusées.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Editez le fichier <literal>07-dhcp-options.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/dnsmasq.d/07-dhcp-options.conf</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier, ajoutez les données suivantes:</simpara>
<programlisting language="ini" linenumbering="unnumbered">dhcp-option=44,[ip_address]     # set netbios-over-TCP/IP nameserver(s) aka WINS server(s) <co xml:id="CO46-1"/>
dhcp-option=45,[ip_address]      # netbios datagram distribution server <co xml:id="CO46-2"/>
dhcp-option=46,8           # netbios node type
dhcp-option=47             # netbios TCP Scope on
port=5353 <co xml:id="CO46-3"/></programlisting>
<calloutlist>
<callout arearefs="CO46-1 CO46-2">
<para>mettez à la place de <literal>[ip_address]</literal> l&#8217;adresse IP de votre serveur samba.</para>
</callout>
<callout arearefs="CO46-3">
<para>cette ligne est à mettre si vous avez une configuration DNSMASQ. Elle n&#8217;est pas utile pour un serveur dhcp standard.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="guest_samba">
<title>Accès "Guest"</title>
<simpara>Sous Windows 10 et 11, l&#8217;accès Guest est désactivé par défaut sur les postes utilisateurs. Il vous faudra autoriser cet accès.</simpara>
<simpara>Pour cela:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Lancez l&#8217;outil regedit.exe</simpara>
</listitem>
<listitem>
<simpara>Allez dans la clé <literal>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters</literal></simpara>
</listitem>
<listitem>
<simpara>Créez une clé <literal>AllowInsecureGuestAuth</literal> de type <literal>dword</literal>.</simpara>
</listitem>
<listitem>
<simpara>Editez la clé <literal>AllowInsecureGuestAuth</literal> et mettez la valeur 1.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_scan_des_vulnérabilités">
<title>Scan des vulnérabilités</title>
<section xml:id="_installation_dun_scanner_de_vulnérabilités_lynis">
<title>Installation d&#8217;un scanner de vulnérabilités Lynis</title>
<simpara>Suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>installer Git. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install git</programlisting>
</listitem>
<listitem>
<simpara>installer Lynis</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd
git clone https://github.com/CISOfy/lynis</programlisting>
</listitem>
<listitem>
<simpara>Executez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd lynis;./lynis audit system</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>L&#8217;outil vous listera dans une forme très synthétique la liste des vulnérabilités et des améliorations de sécurité à appliquer.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_upgrade_de_lynis">
<title>Upgrade de Lynis</title>
<simpara>Pour effectuer la mise à jour de Lynis appliquez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd
cd lynis
git pull</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="_installation_du_système_dadministration_webmin">
<title>Installation du système d&#8217;administration Webmin</title>
<simpara>Webmin est un outil généraliste de configuration de votre serveur. Son usage peut être assez complexe mais il permet une configuration plus précise des fonctionnalités.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Lancez le script de configuration de webmin:</simpara>
<programlisting language="bash" linenumbering="unnumbered">curl -o setup-repos.sh https://raw.githubusercontent.com/webmin/webmin/master/setup-repos.sh
sh setup-repos.sh</programlisting>
</listitem>
<listitem>
<simpara>Mise à jour. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt update</programlisting>
</listitem>
<listitem>
<simpara>Installation de Webmin. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install webmin</programlisting>
</listitem>
<listitem>
<simpara><link linkend="firewall">Debloquez le port 10000 sur votre firewall</link></simpara>
</listitem>
<listitem>
<simpara>Changer le nom du user admin</simpara>
</listitem>
<listitem>
<simpara>Editez le fichier <literal>miniserv.users</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/webmin/miniserv.users</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier remplacer le texte <literal>root</literal> par le nom de votre &lt;sudo_username&gt;.</simpara>
</listitem>
<listitem>
<simpara>De la même manière, éditer le fichier <literal>webmin.acl</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/webmin/webmin.acl</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier remplacer le texte <literal>root</literal> par le nom de votre &lt;sudo_username&gt;.</simpara>
</listitem>
<listitem>
<simpara>Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">service webmin restart</programlisting>
</listitem>
<listitem>
<simpara>Connectez vous avec votre navigateur sur l&#8217;url <link xl:href="https://&lt;example.com&gt;:10000">https://&lt;example.com&gt;:10000</link>. Un message indique un problème de sécurité. Cela vient du certificat auto-signé. Cliquez sur 'Avancé' puis 'Accepter le risque et poursuivre'.</simpara>
</listitem>
<listitem>
<simpara>Loguez-vous &lt;sudo_username&gt;. Tapez le mot de passe de <literal>&lt;sudo_username&gt;</literal>. Le dashboard s&#8217;affiche.</simpara>
</listitem>
<listitem>
<simpara>Restreignez l&#8217;adressage IP</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Obtenez votre adresse IP en allant par exemples sur le site <link xl:href="https://www.showmyip.com/">https://www.showmyip.com/</link></simpara>
</listitem>
<listitem>
<simpara>Sur votre URL Webmin ou vous êtes logué, allez dans Webmin&#8594;Webmin Configuration</simpara>
</listitem>
<listitem>
<simpara>Dans l&#8217;écran choisir l’icône <literal>Ip Access Control</literal>.</simpara>
</listitem>
<listitem>
<simpara>Choisissez <literal>Only allow from listed addresses</literal></simpara>
</listitem>
<listitem>
<simpara>Puis dans le champ <literal>Allowed IP addresses</literal> tapez votre adresse IP récupérée sur showmyip</simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Save</literal></simpara>
</listitem>
<listitem>
<simpara>Vous devriez avoir une brève déconnexion le temps que le serveur Webmin redémarre puis une reconnexion.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Si vous n&#8217;arrivez pas à vous reconnecter c&#8217;est que l&#8217;adresse IP n&#8217;est pas la bonne. Le seul moyen de se reconnecter est de:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Éditez le fichier /etc/webmin/miniserv.conf et supprimez la ligne <literal>allow= &#8230;&#8203;</literal></simpara>
</listitem>
<listitem>
<simpara>Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">service webmin restart</programlisting>
</listitem>
<listitem>
<simpara>Connectez vous sur l&#8217;url de votre site Webmin. Tout doit fonctionner</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Compléments de configuration</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Pour augmenter la sécurité, vous pouvez désactiver le login <literal>sudo_username</literal> et créer un autre compte admin en allant dans: <literal>Webmin</literal> &#8594; <literal>Webmin Users</literal> &#8594; <literal>Create a new privileged user</literal>. Pour le user <literal>sudo_username</literal>, modifier le <literal>Password</literal> en mettant <literal>No password accepted</literal></simpara>
</listitem>
<listitem>
<simpara>Allez dans <literal>Webmin</literal> &#8594; <literal>Webmin Configuration</literal> &#8594; <literal>SSL Encryption</literal> &#8594; onglet <literal>Let&#8217;s Encrypt</literal> &#8594; <literal>Request Certificate</literal>. Attention cette opération ne fonctionne que si le serveur est disponible sur internet.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Passez en Français. Pour les personnes non anglophone. Les traductions française ont des problèmes d&#8217;encodage de caractère ce n&#8217;est donc pas recommandé. La suite de mon tutoriel suppose que vous êtes resté en anglais.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Sur votre url Webmin ou vous êtes logué, allez dans Webmin&#8594;Webmin Configuration</simpara>
</listitem>
<listitem>
<simpara>Dans l&#8217;écran choisir l’icône <literal>Language and Locale</literal>.</simpara>
</listitem>
<listitem>
<simpara>Choisir <literal>Display Language</literal> à <literal>French (FR.UTF-8)</literal></simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_configuration_de_apt_cacher">
<title>Configuration de Apt-cacher</title>
<simpara>L&#8217;outil apt-cacher est un système de cache des paquets debian apt.</simpara>
<simpara>Si vous avez plusieurs machines utilisant debian ou ubuntu sur votre réseau, les mises à jour seront considérablement accélérées par l&#8217;utilisation de ce système de cache.</simpara>
<simpara>Suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Installez le package apt-cacher. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install apt-cacher-ng</programlisting>
</listitem>
<listitem>
<simpara>dans le menu de configuration, choisissez: pas de configuration automatique.</simpara>
</listitem>
<listitem>
<simpara>A la configuration du serveur mandataire, tapez entrée</simpara>
</listitem>
<listitem>
<simpara>A la configuration des adresses locales et des ports tapez entrée.</simpara>
</listitem>
<listitem>
<simpara>enfin autorisez la création de tunnels HTTP</simpara>
</listitem>
<listitem>
<simpara>Éditez le fichier de configuration :</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/apt-cacher-ng/acng.conf</programlisting>
</listitem>
<listitem>
<simpara>Dans ce fichier, recherchez et décommentez les lignes suivantes:</simpara>
<screen linenumbering="unnumbered">CacheDir: /var/cache/apt-cacher-ng
LogDir: /var/log/apt-cacher-ng
ReportPage: acng-report.html
PidFile: /var/run/apt-cacher-ng/pid
ExThreshold: 4</screen>
</listitem>
<listitem>
<simpara>si vous vous avez des repositories particuliers à cacher, vous pouvez éditer le fichier <literal>/etc/apt-cacher-ng/backends_other.default</literal> et ajouter dedans les repositories, comme par exemple: <literal><link xl:href="https://download.docker.com/linux/debian">https://download.docker.com/linux/debian</link></literal></simpara>
</listitem>
<listitem>
<simpara>redémarrez le service. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">/etc/init.d/apt-cacher-ng restart</programlisting>
</listitem>
<listitem>
<simpara>pointez maintenant votre navigateur sur l&#8217;adresse: <link xl:href="http://homeserver.local:3142/">http://homeserver.local:3142/</link></simpara>
</listitem>
<listitem>
<simpara>une page d&#8217;explication de la configuration d&#8217;apt cacher pour les postes clients s&#8217;affiche dans le navigateur.</simpara>
</listitem>
</orderedlist>
<simpara>Sur les postes clients linux:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le poste client</link></simpara>
</listitem>
<listitem>
<simpara>installez le paquet d&#8217;autodéction du proxy apt:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt-get install squid-deb-proxy-client</programlisting>
</listitem>
<listitem>
<simpara>Une autre possibilité est d&#8217;indiquer explicitement l&#8217;adresse du serveur. Dans ce cas, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">echo 'Acquire::http::Proxy "http://homeserver.local:3142";' &gt; /etc/apt/apt.conf.d/02proxy <co xml:id="CO47-1"/></programlisting>
<calloutlist>
<callout arearefs="CO47-1">
<para>remplacez homeserver.local par le nom de votre serveur proxy pour les paquets apt.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_de_docker_et_des_outils_associés">
<title>Installation de Docker et des outils associés</title>
<simpara>Le logiciel <literal>Docker</literal> est une technologie de conteneurisation qui permet la création et l&#8217;utilisation de conteneurs Linux.
En clair, <literal>Docker</literal> permet d&#8217;installer et de configurer rapidement toute une appli web complexe dans un environnement isolé et avec tout son échosystème de bibliothèques logicielles spécifiques.</simpara>
<simpara>Il est ainsi possible d&#8217;effectuer rapidement des installations, de suivre des mises à jours et d&#8217;isoler ces environnements du système principal.</simpara>
<section xml:id="_a_propos_des_raspberry_pi">
<title>A propos des Raspberry Pi</title>
<warning>
<simpara>Les raspberry utilisent une architecture ARM, tous les containeurs ne seront pas forcément compatibles "out of the box" ( Exemple pour MySQL). Sur le <link xl:href="https://hub.docker.com/">Docker Hub</link>, il faut choisir par un Raspberry Pi 4 ou 5 en Ubuntu une architecture de type ARM64 et pour un Raspberry Pi 3 en Raspbian une architecture de type ARM.</simpara>
</warning>
</section>
<section xml:id="_installation_de_docker">
<title>Installation de Docker</title>
<simpara>L&#8217;installation de Docker est relativement simple.</simpara>
<simpara>Il faut suivre les étapes suivantes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Désinstallez les éventuelles anciennes versions de docker. tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt remove --purge docker docker.io containerd runc docker-doc docker-compose podman-docker <co xml:id="CO48-1"/></programlisting>
<calloutlist>
<callout arearefs="CO48-1">
<para>docker-engine n&#8217;existe pas dans une distribution ubuntu. C&#8217;est à enlever.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered"># Add Docker's official GPG key:
apt-get update
apt-get install ca-certificates curl
install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc
chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \
  $(. /etc/os-release &amp;&amp; echo "$VERSION_CODENAME") stable" | \
  tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</programlisting>
</listitem>
<listitem>
<simpara>Une fois installé avec succès, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt update</programlisting>
</listitem>
<listitem>
<simpara>Si vous obtenez une erreur c&#8217;est que vous avez ajouté un repository qui n&#8217;est pas suppporté par Docker. Vérifiez les fichier <literal>/etc/apt/sources.list</literal>.</simpara>
</listitem>
<listitem>
<simpara>Une fois mis à jour avec succès, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</programlisting>
</listitem>
<listitem>
<simpara>vérifiez que votre installation de <literal>Docker</literal> est fonctionnelle. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker run hello-world</programlisting>
</listitem>
<listitem>
<simpara>Cette commande exécute un conteneur simple. Si aucune erreur n’apparaît c&#8217;est que l&#8217;installation est réussie.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_de_docker_swarm">
<title>Installation de docker swarm</title>
<simpara>Docker contient nativement le mode Swarm afin de gérer un ensemble de Docker Engines.
Cette installation est optionnelle puisque l&#8217;on peut faire fonctionner Docker sans cette Option.</simpara>
<simpara>Il y a deux types de machines: les <emphasis role="strong">Managers</emphasis> et les <emphasis role="strong">Workers</emphasis>.</simpara>
<simpara>Les managers : Ce sont les nodes gestionnaires de votre cluster. Ils distribuent les tâches aux nodes workers et ils effectuent également les fonctions d&#8217;orchestration et de gestion.</simpara>
<simpara>Les workers : Ils vont exécuter les tâches confiées par les managers. Un agent s&#8217;exécute sur chaque nœud et rend compte des tâches qui lui sont affectées. Il informe ainsi les nodes managers de l&#8217;état des tâches affectées.</simpara>
<simpara>Il faut suivre les étapes suivantes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker swarm init</programlisting>
</listitem>
<listitem>
<simpara>Le résultat de la commande donne la commande <literal>docker swarm join</literal> a exécuter sur un "worker"  pour lui faire rejoindre le "swarm". A noter que le "manager" que nous venons de creer est aussi un worker. De ce fait, un swarm peut être installé de façon standalone sur un VPS.</simpara>
</listitem>
<listitem>
<simpara>Vous pouvez maintenant vérifier l&#8217;état de votre cluster. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker node ls</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_choix_des_images_docker">
<title>Choix des images docker</title>
<simpara>Les images docker sont accessibles sur le <link xl:href="https://hub.docker.com/">Docker Hub</link>.</simpara>
<simpara>Mais voilà, c&#8217;est un peu la jungle. Un bon moyen de trouver des images à jour d&#8217;un point de vue sécurité et non compromises est de ne sélectionner que des images "Docker Certified" ou "Verified Publisher" ou "Official Images".</simpara>
<simpara>Du moins on est sûr que ces images ont été à minima vérifiées par les équipes Docker.</simpara>
<simpara>Pour mémoire: <emphasis role="strong">Le nombre de chargement d&#8217;une image n&#8217;est pas un gage de qualité !</emphasis></simpara>
<simpara>Si vous n&#8217;utilisez pas une image du type mentionné ci dessus, l&#8217;accès facile au fichier Dockerfile est un gage de qualité et de transparence. En tout cas, il vous sera facilement possible de regarder comment l&#8217;image est construite et quels sont les package dockers de base et si ces packages dockers de base sont récents et certifiés.</simpara>
<simpara>Pour les plateformes de type Raspberry, il faut bien vérifier que l&#8217;image docker que vous chargez est compatible de votre plateforme. Sur Docker Hub, vous devez allez sur l&#8217;onglet Tag de votre package et vérifier que le champ OS/ARCH contient bien votre plateforme.</simpara>
<simpara>Pour un Raspberry Pi 4 ou 5 ce doit être: <literal>Linux/arm64</literal></simpara>
<simpara>Pour un Raspberry Pi 3 ce doit être: <literal>Linux/arm</literal></simpara>
<simpara>Par exemple pour les docker de <literal>Yacht</literal> et de <literal>Portainer</literal> décrits ci après, on peut voir que les containers sont multiplateforme et conviennent très bien pour de l&#8217;Intel ou de l&#8217;ARM.</simpara>
</section>
<section xml:id="_considérations_de_sécurité">
<title>Considérations de sécurité</title>
<simpara>A propos de l&#8217;export des ports sous docker.</simpara>
<simpara>Par défaut lorsque vous lancez un container docker, l&#8217;option pour exporter un port de votre docker vers votre machine est <literal>-p dst_port:src_port</literal>.
Si vous indiquez uniquement le port de destination comme par exemple dans <literal>-p 80:8080</literal> qui exporte le port 8080 de votre docker vers le port 80 de votre machine réelle, vous exporter vers le port 80 de l&#8217;adresse IP 0.0.0.0 ce qui en pratique indique que vous n&#8217;utilisez pas les règles du firewall; le port est exporté automatiquement sur toutes les interfaces.</simpara>
<simpara>De ce fait, vous exposez tous les ports interne de votre système docker à tout internet et le firewall ne bloque rien pour ces ports.</simpara>
<simpara>Il est donc indispensable pour une machine directement exposée sur internet d&#8217;indiquer l&#8217;adresse du loopback en indiquant systématiquement l&#8217;adresse IP soit <literal>-p 127.0.0.1:80:8080</literal>. Ainsi les règles du firewall sont appliquées et vous pourrez par votre configuration d&#8217;ISPconfig n&#8217;exposer que les ports et noms de domaines nécessaires.</simpara>
<important>
<simpara>Dans tout ce qui suit nous omettrons d&#8217;utiliser cette adresse en 127.0.0.1 . Pensez bien donc à ajouter cette adresse systématiquement pour un serveur présent sur le web !</simpara>
</important>
</section>
<section xml:id="_mise_à_jour_automatique_des_images">
<title>Mise à jour automatique des images</title>
<simpara>Vos images docker peuvent être mise à jour automatiquement si vous les avez installés à partir du docker hub ou de n&#8217;importe quel autre repository compatible.</simpara>
<simpara>Un outil automatise cette mise à jour c&#8217;est <link xl:href="https://github.com/containrrr/watchtower">watchtower</link>.</simpara>
<simpara>Pour l&#8217;installer, rien de plus simple:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker run -d --name watchtower -v /var/run/docker.sock:/var/run/docker.sock containrrr/watchtower --cleanup --interval 86400</programlisting>
</listitem>
<listitem>
<simpara>l&#8217;option cleanup effectue le ménage des images inutiles et interval indique en secondes le temps à attendre entre deux vérifications (ici 24h)</simpara>
</listitem>
<listitem>
<simpara>si vous voulez vous connecter à un repository avec un login et un mot de passe, vous pouvez ajouter au lancement du docker les options suivantes:</simpara>
<programlisting language="bash" linenumbering="unnumbered">-e REPO_USER=username -e REPO_PASS=password</programlisting>
</listitem>
<listitem>
<simpara>Si vous désirez ne mettre à jour que certains containers, vous pouvez passer l&#8217;option <literal>--label-enable</literal> et ensuite désigner les container à mettre à jour en leur passant le label <literal>-l com.centurylinklabs.watchtower.enable=true</literal></simpara>
</listitem>
<listitem>
<simpara>Enfin dernière option très utile la possibilité de décider de la période de mise à jour à l&#8217;aide d&#8217;une expression de type cron. Comme exemple: <literal>--schedule "0 0 4 * * *"</literal> mettra à jour à 0h0 tous les 4 de chaque mois.</simpara>
</listitem>
<listitem>
<simpara>Enfin lorsqu&#8217;une mise à jour s&#8217;effectue vous pouvez être notifié par mail, slack ou d&#8217;autres outils tels que shoutrrr. Se référer à la <link xl:href="https://containrrr.dev/watchtower/notifications/">documentation</link></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_surveillance_et_redémarrage_de_container">
<title>Surveillance et redémarrage de container</title>
<simpara>Il peut arriver que certains container s&#8217;arrêtent brusquement suite à un bug.</simpara>
<simpara>Autoheal est unn outil qui redémarre ces container automatiquement en se basant sur l&#8217;attribut healthcheck des containers.</simpara>
<simpara>La documentation est <link xl:href="https://github.com/willfarrell/docker-autoheal">ici</link>.</simpara>
<simpara>Pour l&#8217;installer:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker run -d --name autoheal --restart=always -e AUTOHEAL_CONTAINER_LABEL=all -v /var/run/docker.sock:/var/run/docker.sock willfarrell/autoheal</programlisting>
</listitem>
<listitem>
<simpara>La variable d&#8217;environnement AUTOHEAL_CONTAINER_LABEL indique que tous les containers seront vérifiés. Si vous souhaitez uniquement indiquer les container à vérifier, il vous faut ajouter pour les container concernés l&#8217;otion <literal>-l autoheal=true</literal></simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_installation_de_traefik">
<title>Installation de Traefik</title>
<simpara>Le logiciel <literal>Traefik</literal> est une technologie de Reverse Proxy qui est un intermédiaire de communication, entre un réseau public et un réseau privé, le nôtre par exemple. C’est sur ce réseau privé que l’on trouvera toutes les applications qui ne sont pas accessibles depuis l’extérieur pour des raisons de sécurité ou de découpe en microservices.</simpara>
<simpara>Traefik permet donc de faire de la “configuration discovery” via plusieurs fournisseurs de services et load balancer pour HTTP et TCP. Il offre également d’autres fonctionnalités comme le support de Let’s Encrypt, des middlewares et la possibilité de monitorer facilement des services.</simpara>
<section xml:id="_installation_de_traefik_2">
<title>Installation de Traefik</title>
<simpara>L&#8217;installation de Traefik est simple.</simpara>
<simpara>Il faut suivre les étapes suivantes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Assurez vous tout d&#8217;abord qu&#8217;un serveur web n&#8217;est pas actif sur le port 80 de votre Machine. C&#8217;est Traefik qui en prendra la place et servira les pages nécessaires. Il vous faudra soit désactiver tout serveur Apache local soit vérifier que ce serveur apache n&#8217;utilise pas le port 80.</simpara>
</listitem>
<listitem>
<simpara>Pour désactiver lighttpd ou apache2. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">service lighttpd stop
service apache stop</programlisting>
</listitem>
<listitem>
<simpara>Ensuite installez Traefik. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker run -d --name traefik --restart=always -v /var/run/docker.sock:/var/run/docker.sock -p80:80 -p8080:8080 --api.insecure=true --api.dashboard=true --providers.docker --log.level=DEBUG <co xml:id="CO49-1"/></programlisting>
<calloutlist>
<callout arearefs="CO49-1">
<para>Si votre serveur Traefik est disponible sur internet, il ne faudra pas exposer le port 8080 et les api insecure. et de ce fait, dans la ligne précédente, supprimez: <literal>-p8080:8080 --api.insecure=true --api.dashboard=true</literal></para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_configuration_de_traefik_pour_une_utilisation_avec_pi_hole">
<title>Configuration de Traefik pour une utilisation avec Pi-Hole</title>
<simpara>Pi-Hole se configure avec un serveur lighttpd sur votre machine en utilisant le port 80. Il est possible d&#8217;utiliser Pi-Hole et Traefik en même temps pour servir plusieurs site webs sur la même machine</simpara>
<simpara>Appliquer la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Reconfigurez Pi Hole pour utiliser un autre port que le port 80 sur la machine local. Pour cela éditez le fichier <literal>external.conf</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/lighttpd/external.conf</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier insèrez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">server.port:=3080</programlisting>
</listitem>
<listitem>
<simpara>Sauvegardez et redémarrez lighttpd. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">service lighttpd restart</programlisting>
</listitem>
<listitem>
<simpara>Vérifier que lighttpd n&#8217;est plus accessible dans votre navigateur sur le port 80 mais sur le port 3080.</simpara>
</listitem>
<listitem>
<simpara>Editez un fichier de configuration statique Traefik. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir /etc/traefik
vi /etc/traefik/traefik.yml</programlisting>
</listitem>
<listitem>
<simpara>Dans ce fichier, tapez le contenu suivant:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">logLevel: Debug

providers:
  docker:
    defaultRule: "Host(`{{ trimPrefix `/` .Name }}.example.com`)" <co xml:id="CO50-1"/>
    watch: true
  file:
    filename: /etc/traefik/dynamic_conf.yml
    watch: true

defaultEntryPoints:
  - https
  - http

entryPoints:
  http:
    address: :80</programlisting>
<calloutlist>
<callout arearefs="CO50-1">
<para>Remplacez example.com par le nom de domaine de votre serveur.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Editez le fichier de configuration dynamique. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/traefik/dynamic_conf.yml</programlisting>
</listitem>
<listitem>
<simpara>Dans ce fichier, tapez le contenu suivant:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">http:
  routers:
    lighttpd:
      entrypoints:
        - http
      service: localserver
      rule: host("example.com") <co xml:id="CO51-1"/>
  services:
    localserver:
      loadBalancer:
        servers:
          - url: "http://ip_address:3080" <co xml:id="CO51-2"/></programlisting>
<calloutlist>
<callout arearefs="CO51-1">
<para>Remplacez example.com par le nom de domaine de votre serveur.</para>
</callout>
<callout arearefs="CO51-2">
<para>remplacez ip_address par l&#8217;adresse IP de votre serveur.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Arrêtez votre ancienne instance Traefik, si Traefik a été lancé. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker stop traefik
docker rm traefik</programlisting>
</listitem>
<listitem>
<simpara>Relancez Traefik avec la nouvelle configuration:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker run -d --name traefik --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /etc/traefik:/etc/traefik -p80:80 -p8080:8080 traefik --api.insecure=true --api.dashboard=true --providers.docker --log.level=DEBUG</programlisting>
</listitem>
<listitem>
<simpara>Pihole est maintenant de nouveau accessible sur le port 80 et Traefik est actif en même temps pour servir tout un ensemble de sous-domaines virtuels associés à l&#8217;environnement Docker.</simpara>
</listitem>
<listitem>
<simpara>Pour superviser vos routes et services Traefik, vous pouvez vous connecter sur <literal>http:example.com:8080</literal> pour voir la configuration en cours. (example.com est à remplacer pour le nom de votre machine).</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_upgrade_de_traefik">
<title>Upgrade de Traefik</title>
<simpara>Rien a faire pour la mise à jour si vous utilisez <literal>Watchtower</literal>
Vous pouvez aussi appliquer la procédure de mise à jour des containers à l&#8217;aide de <link linkend="port_container_updt"><literal>Portainer</literal></link> ou à l&#8217;aide <link linkend="yacht_container_updt"><literal>Yacht</literal></link></simpara>
<simpara>Sinon, effectuez les opérations suivantes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Allez dans le répertoire de root</simpara>
</listitem>
<listitem>
<simpara>Mettez à jour le docker de Traefik. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker pull traefik
docker stop traefik
docker rm traefik
docker run -d --name traefik --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /etc/traefik:/etc/traefik -p80:80 -p8080:8080 traefik --api.insecure=true --api.dashboard=true --providers.docker --log.level=DEBUG <co xml:id="CO52-1"/></programlisting>
<calloutlist>
<callout arearefs="CO52-1">
<para>supprimez <literal>-v /etc/traefik:/etc/traefik</literal> si vous n&#8217;utilisez pas Pi-Hole avec Treafik.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_outils_web_de_gestion_des_containers">
<title>Outils web de gestion des containers</title>
<section xml:id="_installation_de_yacht">
<title>Installation de Yacht</title>
<simpara>Yacht est un outil d&#8217;administration de vos instances docker sous forme de site web. Yacht est très facile d&#8217;utilisation mais manque de possibilités du moins dans la version actuelle. Si vous souhaitez administrer de façon plus avancée vos instances docker, il est conseillé d&#8217;utiliser Portainer.</simpara>
<simpara>Yacht s’installe comme un conteneur docker pour simplifier son déploiement.</simpara>
<simpara>Pour la création du site web, il faut suivre les étapes suivantes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Allez dans ISPConfig dans la rubrique <literal>DNS</literal>, sélectionnez le menu <literal>Zones</literal>, Sélectionnez votre Zone, Allez dans l&#8217;onglet <literal>Records</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Cliquez sur <literal>A</literal> et saisissez:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Hostname:</literal> &#8592; Tapez <literal>yacht</literal></simpara>
</listitem>
<listitem>
<simpara><literal>IP-Address:</literal> &#8592; Double cliquez et sélectionnez l&#8217;adresse IP de votre serveur</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Save</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Créer un <link linkend="subdomain-site">sub-domain (vhost)</link> dans le configurateur de sites.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Lui donner le nom <literal>yacht</literal>.</simpara>
</listitem>
<listitem>
<simpara>Le faire pointer vers le web folder <literal>yacht</literal>.</simpara>
</listitem>
<listitem>
<simpara>Sélectionnez <literal>None</literal> dans <literal>Auto-subdomain</literal></simpara>
</listitem>
<listitem>
<simpara>Activer <literal>let’s encrypt SSL</literal></simpara>
</listitem>
<listitem>
<simpara>Activer <literal>PHP-FPM</literal> pour PHP</simpara>
</listitem>
<listitem>
<simpara>Dans l&#8217;onglet Redirect Cochez la case <literal>Rewrite HTTP to HTTPS</literal></simpara>
</listitem>
<listitem>
<simpara>Laisser le reste par défaut.</simpara>
</listitem>
<listitem>
<simpara>Dans l’onglet Options:</simpara>
</listitem>
<listitem>
<simpara>Dans la boite <literal>Apache Directives:</literal> saisir le texte suivant:</simpara>
<programlisting language="apache" linenumbering="unnumbered">&lt;Proxy *&gt;
Order deny,allow
Allow from all
&lt;/Proxy&gt;

ProxyRequests Off
ProxyPass /stats !
ProxyPass /.well-known/acme-challenge !

# yacht httpserver
#

SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
ProxyPreserveHost    On

ProxyPass / http://localhost:8061/
ProxyPassReverse / http://localhost:8061/

RedirectMatch ^/$ https://yacht.example.com <co xml:id="CO53-1"/></programlisting>
<calloutlist>
<callout arearefs="CO53-1">
<para>remplacer <literal>example.com</literal> par votre nom de domaine</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Puis sur votre serveur, <link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker volume create yacht_data
docker run -d -p 8061:8000 --name=yacht -v /var/run/docker.sock:/var/run/docker.sock --restart=always -v yacht_data:/config selfhostedpro/yacht</programlisting>
</listitem>
<listitem>
<simpara>Ouvrez un navigateur et pointez sur <link xl:href="http://yacht.example.com">http://yacht.example.com</link></simpara>
</listitem>
<listitem>
<simpara>L&#8217;utilisateur par défaut est login: <literal>admin@yacht.local</literal> et mot de passe: <literal>pass</literal>.</simpara>
</listitem>
<listitem>
<simpara>Une fois loggué, Cliquez sur l&#8217;utilisateur en haut à droite et <literal>user</literal>.</simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>change password</literal></simpara>
</listitem>
<listitem>
<simpara>Modifier votre Email de login et saisissez un nouveau mot de passe.</simpara>
</listitem>
<listitem>
<simpara>Cliquez ensuite sur <literal>Templates</literal> dans la barre vertical de gauche puis sur <literal>New templates</literal></simpara>
</listitem>
<listitem>
<simpara>Copiez la suggestion de template proposée.</simpara>
</listitem>
<listitem>
<simpara>Saisissez un titre <literal>Yacht</literal> dans le champ <literal>Title</literal> puis collez l&#8217;URL du json dans le champ <literal>URL</literal></simpara>
</listitem>
<listitem>
<simpara>Cliquez sur Submit.</simpara>
</listitem>
<listitem>
<simpara>Allez dans <literal>Templates</literal> &#8594; <literal>View Templates</literal>.</simpara>
</listitem>
<listitem>
<simpara>cliquez sur <literal>Yacht</literal>; vous avez maintenant accès à une foule de templates.</simpara>
</listitem>
<listitem>
<simpara>Vous pouvez maintenant administrer vos machines docker. Référez vous à la documentation de <link xl:href="https://yacht.sh/Pages/dashboard/">Yacht</link> pour installer de nouvelles machines docker</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="yacht_container_updt">
<title>Upgrade d&#8217;un container dans Yacht</title>
<simpara>Plutôt que d’effectuer des mises à jour automatiques avec Watchtower, vous préférerez mettre à jour manuellement avec Yacht.</simpara>
<simpara>Appliquez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Ouvrez un navigateur et pointez sur <link xl:href="http://yacht.example.com">http://yacht.example.com</link></simpara>
</listitem>
<listitem>
<simpara>Logguez vous en tant qu'`admin`</simpara>
</listitem>
<listitem>
<simpara>Allez  dans l&#8217;onglet <literal>Applications</literal></simpara>
</listitem>
<listitem>
<simpara>Cliquez sur le bouton <literal>Updates</literal></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_upgrade_de_yacht">
<title>Upgrade de Yacht</title>
<simpara>Rien a faire pour la mise à jour si vous utilisez <literal>Watchtower</literal>
Vous pouvez aussi appliquer la procédure de mise à jour des <link linkend="port_container_updt">containers à l&#8217;aide de <literal>Portainer</literal></link></simpara>
<simpara>Sinon, effectuez les opérations suivantes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Allez dans le répertoire de root</simpara>
</listitem>
<listitem>
<simpara>Mettez à jour le docker de Yacht. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker pull selfhostedpro/yacht
docker stop yacht
docker rm yacht
docker run -d -p 8061:8000 --name=yacht -v /var/run/docker.sock:/var/run/docker.sock --restart=always -v yacht_data:/config selfhostedpro/yacht</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_de_portainer">
<title>Installation de Portainer</title>
<simpara>Portainer est un outil d&#8217;administration de vos instances docker sous forme de site web. Portainer est plus complexe à utiliser que Yacht, mais offre cependant beaucoup plus de possibilités.</simpara>
<simpara>Portainer s’installe comme un conteneur docker pour simplifier son déploiement. Portainer gère une bonne partie des éléments de docker : conteneurs, images, volumes, réseaux, utilisateurs</simpara>
<simpara>Pour la création du site web, il faut suivre les étapes suivantes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Allez dans ISPConfig dans la rubrique <literal>DNS</literal>, sélectionnez le menu <literal>Zones</literal>, Sélectionnez votre Zone, Allez dans l&#8217;onglet <literal>Records</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Cliquez sur <literal>A</literal> et saisissez:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Hostname:</literal> &#8592; Tapez <literal>portainer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>IP-Address:</literal> &#8592; Double cliquez et sélectionnez l&#8217;adresse IP de votre serveur</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Save</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Créer un <link linkend="subdomain-site">sub-domain (vhost)</link> dans le configurateur de sites.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Lui donner le nom <literal>portainer</literal>.</simpara>
</listitem>
<listitem>
<simpara>Le faire pointer vers le web folder <literal>portainer</literal>.</simpara>
</listitem>
<listitem>
<simpara>Sélectionnez <literal>None</literal> dans <literal>Auto-subdomain</literal></simpara>
</listitem>
<listitem>
<simpara>Activer <literal>let’s encrypt SSL</literal></simpara>
</listitem>
<listitem>
<simpara>Activer <literal>PHP-FPM</literal> pour PHP</simpara>
</listitem>
<listitem>
<simpara>Dans l&#8217;onglet Redirect Cochez la case <literal>Rewrite HTTP to HTTPS</literal></simpara>
</listitem>
<listitem>
<simpara>Laisser le reste par défaut.</simpara>
</listitem>
<listitem>
<simpara>Dans l’onglet Options:</simpara>
</listitem>
<listitem>
<simpara>Dans la boite <literal>Apache Directives:</literal> saisir le texte suivant:</simpara>
<programlisting language="apache" linenumbering="unnumbered">&lt;Proxy *&gt;
Order deny,allow
Allow from all
&lt;/Proxy&gt;

ProxyRequests Off
ProxyPass /stats !
ProxyPass /.well-known/acme-challenge !

# portainer httpserver
#

SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
ProxyPreserveHost    On

ProxyPass / http://localhost:9050/
ProxyPassReverse / http://localhost:9050/

RedirectMatch ^/$ https://portainer.example.com <co xml:id="CO54-1"/></programlisting>
<calloutlist>
<callout arearefs="CO54-1">
<para>remplacer <literal>example.com</literal> par votre nom de domaine</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Puis sur votre serveur, <link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker volume create portainer_data
docker run -d -p 9050:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce</programlisting>
</listitem>
<listitem>
<simpara>Ouvrez un navigateur et pointez sur <link xl:href="http://portainer.example.com">http://portainer.example.com</link></simpara>
</listitem>
<listitem>
<simpara>Créez votre utilisateur de <literal>admin</literal> avec un mot de passe sécurisé.</simpara>
</listitem>
<listitem>
<simpara>Ajoutez un endpoint <literal>Local</literal></simpara>
</listitem>
<listitem>
<simpara>Vous pouvez maintenant administrer vos machines docker. Référez vous à la documentation de <link xl:href="https://documentation.portainer.io/v2.0/stacks/create/">portainer</link> pour installer de nouvelles machines docker</simpara>
</listitem>
</orderedlist>
<simpara>Portainer offre la possibilité d&#8217;installer des templates par défaut. Vous pouvez soit garder le repository par défault : <literal><link xl:href="https://raw.githubusercontent.com/portainer/templates/master/templates-2.0.json">https://raw.githubusercontent.com/portainer/templates/master/templates-2.0.json</link></literal> ou utiliser un autre repository comme: <literal><link xl:href="https://raw.githubusercontent.com/Qballjos/portainer_templates/master/Template/template.json">https://raw.githubusercontent.com/Qballjos/portainer_templates/master/Template/template.json</link></literal>:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>allez sur votre site web portainer.</simpara>
</listitem>
<listitem>
<simpara>puis dans le menu Settings</simpara>
</listitem>
<listitem>
<simpara>Dans la zone <literal>App Templates</literal> saisissez le repository de votre choix dans le champ <literal>URL</literal></simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Save Settings</literal></simpara>
</listitem>
<listitem>
<simpara>retournez dans le menu <literal>App Templates</literal>; vos nouveau templates sont maintenant affichés.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="port_container_updt">
<title>Upgrade d&#8217;un container dans Portainer</title>
<simpara>Plutôt que d’effectuer des mises à jour automatiques avec Watchtower, vous préférerez mettre à jour manuellement avec Portainer.</simpara>
<simpara>Appliquez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Ouvrez un navigateur et pointez sur <link xl:href="http://portainer.example.com">http://portainer.example.com</link></simpara>
</listitem>
<listitem>
<simpara>Logguez vous en tant qu' <literal>admin</literal></simpara>
</listitem>
<listitem>
<simpara>Allez  dans l&#8217;onglet <literal>Containers</literal></simpara>
</listitem>
<listitem>
<simpara>Double-cliquez sur le container à mettre à jour</simpara>
</listitem>
<listitem>
<simpara>Dans le nouvel écran <literal>Container details</literal> cliquez sur l&#8217;icone <literal>recreate</literal></simpara>
</listitem>
<listitem>
<simpara>Sélectionnez <literal>Pull latest image</literal> et cliquez <literal>recreate</literal></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_upgrade_de_portainer">
<title>Upgrade de Portainer</title>
<simpara>Rien a faire pour la mise à jour si vous utilisez <literal>Watchtower</literal>
Vous pouvez aussi appliquer la procédure de mise à jour des containers à l&#8217;aide de <link linkend="yacht_container_updt"><literal>Yacht</literal></link></simpara>
<simpara>Sinon, effectuez les opérations suivantes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Allez dans le répertoire de root</simpara>
</listitem>
<listitem>
<simpara>Mettez à jour le docker de Yacht. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker pull portainer/portainer-ce
docker stop portainer
docker rm portainer
docker run -d -p 9050:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_configuration_de_docker_mirror">
<title>Configuration de Docker-mirror</title>
<simpara>L&#8217;outil Docker-mirror est un système de cache de fichier Dockers.</simpara>
<simpara>Si vous avez plusieurs machines utilisant docker sur votre réseau, les déploiements et les mises à jour seront considérablement accélérées par l&#8217;utilisation de ce système de cache.</simpara>
<simpara>Suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Obtenez une configuration initiale pour le fichier <literal>config.yml</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker run -it --rm --entrypoint cat registry:2 /etc/docker/registry/config.yml &gt; /etc/docker-mirror.yml</programlisting>
</listitem>
<listitem>
<simpara>Ajoutez ceci dans le fichier <literal>config.yml</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/docker-mirror.yml</programlisting>
</listitem>
<listitem>
<simpara>Dans ce fichier, ajoutez les lignes suivantes :</simpara>
<screen linenumbering="unnumbered">proxy:
      remoteurl: https://registry-1.docker.io</screen>
</listitem>
<listitem>
<simpara>Démarrez ensuite le service docker. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker run -d --restart=always -p 5000:5000 --name docker-registry-proxy -v /etc/docker-mirror.yml:/etc/docker/registry/config.yml registry:2</programlisting>
</listitem>
</orderedlist>
<simpara>Sur le poste client, soit passez l&#8217;option --registry-mirror lorsque vous lancez le démon <literal>dockerd</literal> ou sinon éditez le fichier <literal>/etc/docker/daemon.json</literal> et ajoutez la clé <literal>registry-mirrors</literal> pour rendre le changement persistant:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le poste client</link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/docker/daemon.json</programlisting>
</listitem>
<listitem>
<simpara>Dans le fichier, ajoutez:</simpara>
<screen linenumbering="unnumbered">{
  "registry-mirrors": ["http://docker.example.com:5000"] <co xml:id="CO55-1"/>
}</screen>
<calloutlist>
<callout arearefs="CO55-1">
<para>remplacer <literal>docker.example.com</literal> par le nom ou l&#8217;adresse ip de votre cache docker.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Sauvegarder le fichier et redémarrez le démon docker. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">systemctl restart docker</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_de_statping">
<title>Installation de Statping</title>
<simpara>Statping récupérera automatiquement l&#8217;état de vos applications web et génèrera une belle page d&#8217;état avec des tonnes de fonctionnalités pour vous permettre de construire une page d&#8217;état encore plus détaillée.
Statping est mini d&#8217;une appli smartphone qui vos permettra de consulter les statuts de votre site</simpara>
<simpara>Des alertes peuvent être envoyées par mail sms ou autre.</simpara>
<section xml:id="_prérequis">
<title>Prérequis</title>
<simpara>Il vous faudra tout d&#8217;abord installer <literal>docker</literal> en vous référant au chapitre qui y est consacré.</simpara>
</section>
<section xml:id="_installation_du_serveur_statping">
<title>Installation du serveur Statping</title>
<simpara>Nous allons installer Statping à partir de son container Docker.</simpara>
<simpara>Ouvrez un terminal et suivez la procédure:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Allez dans le répertoire de root</simpara>
</listitem>
<listitem>
<simpara>Créez le docker de Statping. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker volume create statping_data
docker run -d --name=statping -p 8035:8080 -v statping_data:/app --restart always statping/statping</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_création_du_site_web_de_statping">
<title>Création du site web de statping</title>
<simpara>Appliquez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Allez dans la rubrique <literal>DNS</literal>, sélectionnez le menu <literal>Zones</literal>, Sélectionnez votre Zone, Allez dans l&#8217;onglet <literal>Records</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Cliquez sur <literal>A</literal> et saisissez:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Hostname:</literal> &#8592; Tapez <literal>statping</literal></simpara>
</listitem>
<listitem>
<simpara><literal>IP-Address:</literal> &#8592; Double cliquez et sélectionnez l&#8217;adresse IP de votre serveur</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Save</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Créer un <link linkend="subdomain-site">sub-domain (vhost)</link> dans le configurateur de sites.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Lui donner le nom <literal>statping</literal>.</simpara>
</listitem>
<listitem>
<simpara>Le faire pointer vers le web folder <literal>statping</literal>.</simpara>
</listitem>
<listitem>
<simpara>Dans auto-Subdomain &#8592; Sélectionnez <literal>None</literal></simpara>
</listitem>
<listitem>
<simpara>Sélectionnez <literal>None</literal> dans <literal>Auto-subdomain</literal></simpara>
</listitem>
<listitem>
<simpara>Activer <literal>let’s encrypt SSL</literal></simpara>
</listitem>
<listitem>
<simpara>Activer <literal>PHP-FPM</literal> pour PHP</simpara>
</listitem>
<listitem>
<simpara>Dans l&#8217;onglet Redirect Cochez la case <literal>Rewrite HTTP to HTTPS</literal></simpara>
</listitem>
<listitem>
<simpara>Laisser le reste par défaut.</simpara>
</listitem>
<listitem>
<simpara>Dans l’onglet Options:</simpara>
</listitem>
<listitem>
<simpara>Dans la boite <literal>Apache Directives:</literal> saisir le texte suivant:</simpara>
<programlisting language="apache" linenumbering="unnumbered">&lt;Proxy *&gt;
Order deny,allow
Allow from all
&lt;/Proxy&gt;

ProxyRequests Off
ProxyPass /stats !
ProxyPass /.well-known/acme-challenge !

# statping httpserver
#

SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
ProxyPreserveHost    On

ProxyPass / http://localhost:8035/
ProxyPassReverse / http://localhost:8035/

RedirectMatch ^/$ https://statping.example.com <co xml:id="CO56-1"/></programlisting>
<calloutlist>
<callout arearefs="CO56-1">
<para>remplacer <literal>example.com</literal> par votre nom de domaine</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_configuration_du_site_statping">
<title>Configuration du site statping</title>
<simpara>Votre site web <literal>statping</literal> est installé et opérationnel.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Pointez votre navigateur sur votre site web <literal>statping</literal></simpara>
</listitem>
<listitem>
<simpara>une page de configuration apparait. Saisissez:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>Language</literal> &#8594; <literal>French</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Connexion à la Base</literal> &#8594; <literal>Sqlite</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Nom de la page d&#8217;état</literal> &#8594; <literal>Statut des serveurs</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Description</literal> &#8594; <literal>Monitoring de l&#8217;état de tous les serveurs</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Domaine</literal> &#8594; <literal><link xl:href="https://statping.example.com">https://statping.example.com</link></literal> mettre le nom de votre domaine à la place de example.com</simpara>
</listitem>
<listitem>
<simpara><literal>Nom d&#8217;utilisateur</literal> &#8594; <literal>admin</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mot de passe</literal> et <literal>confirmer Le</literal> &#8594; Saisissez <link linkend="pass_gen">un mot de passe généré</link></simpara>
</listitem>
<listitem>
<simpara><literal>Email</literal> &#8594; saisissez votre email</simpara>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>enregistrer</literal>. Vous avez alors accès à la page principale de <literal>Statping</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Allez sur le <literal>dashboard</literal> et logguez vous.</simpara>
</listitem>
<listitem>
<simpara>Vous pouvez alors configurer statping. Pour la documentation allez  <link xl:href="https://github.com/statping/statping/wiki">https://github.com/statping/statping/wiki</link></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_upgrade_de_statping">
<title>Upgrade de Statping</title>
<simpara>Rien a faire pour la mise à jour si vous utilisez <literal>Watchtower</literal>
Vous pouvez aussi appliquer la procédure de mise à jour des containers à l&#8217;aide de <link linkend="port_container_updt"><literal>Portainer</literal></link> ou à l&#8217;aide <link linkend="yacht_container_updt"><literal>Yacht</literal></link></simpara>
<simpara>Sinon, effectuez les opérations suivantes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur le serveur</link></simpara>
</listitem>
<listitem>
<simpara>Allez dans le répertoire de root</simpara>
</listitem>
<listitem>
<simpara>Mettez à jour le docker de Mealie. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">docker pull statping/statping:latest
docker stop statping
docker rm statping
docker run -d --name=statping -p 8035:8080 -v statping_data:/app --restart always statping/statping</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_installation_du_système_de_backup_borgbackup">
<title>Installation du système de backup BorgBackup</title>
<simpara>BorgBackup est un système de backup simple mais offrant des fonctionnalités avancées telles que le backup incrémental, la déduplication de données, la compression, l&#8217;authentification, l&#8217;encryption.</simpara>
<simpara>Borg backup est un système de backup offsite. Cela signifie que vous devez avoir accès à un espace de stockage sur un autre site pour effectuer cette sauvegarde.</simpara>
<simpara>Pour le moment, BorgBackup n&#8217;utilise pas de mécanisme de type RClone et il n&#8217;est donc pas encore possible de sauvegarder sur google drive ou autres espaces partagés.</simpara>
<section xml:id="_introduction">
<title>Introduction</title>
<simpara>BorgBackup permet de stocker des backups sur un serveur distant.
Nous nommerons le serveur sur lequel les sauvegardes seront stockées : serveur de stockage et identifié par &lt;storing_srv&gt;.
Nous nommerons le serveur qu&#8217;il faut sauvegarder: serveur sauvegardé et identifié par &lt;example.com&gt;</simpara>
</section>
<section xml:id="_installation_du_serveur_de_stockage">
<title>Installation du serveur de stockage</title>
<simpara>Il est préférable pour des questions de sécurité de créer un compte utilisateur spécifique.</simpara>
<simpara>Suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur &lt;storing_srv&gt;. </link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install borgbackup</programlisting>
</listitem>
<listitem>
<simpara><link linkend="pass_gen">Générez un mot de passe long</link></simpara>
<important>
<simpara>Sauvegardez précieusement ce mot de passe. Il vous sera indispensable pour récupérer vos backup après un crash du serveur. Sans celui-ci, impossible de récupérer votre installation !</simpara>
</important>
</listitem>
<listitem>
<simpara>Créez un compte utilisateur. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">adduser borgbackup</programlisting>
</listitem>
<listitem>
<simpara>Copiez-collez le mot de passe généré lorsqu&#8217;il est demandé</simpara>
</listitem>
<listitem>
<simpara>se loguer comme <literal>borgbackup</literal></simpara>
</listitem>
<listitem>
<simpara>Créer un répertoire <literal>~/.ssh</literal> s&#8217;il n&#8217;existe pas. tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p $HOME/.ssh
chmod 700 ~/.ssh</programlisting>
</listitem>
<listitem>
<simpara>Allez dans le répertoire. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd ~/.ssh</programlisting>
</listitem>
<listitem>
<simpara>Générez vous clés. Tapez :</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh-keygen -t rsa</programlisting>
</listitem>
<listitem>
<simpara>Un ensemble de questions apparaît. Si un texte vous explique que le fichier existe déjà, arrêtez la procédure. Cela signifie que vous avez déjà créé une clé et que vous risquez de perdre la connexion à d&#8217;autres serveurs si vous en générez une nouvelle. Sinon, appuyez sur Entrée à chaque fois pour accepter les valeurs par défaut.</simpara>
</listitem>
<listitem>
<simpara>Créez maintenant le répertoire pour recevoir les sauvegardes</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd
mkdir borgbackup
chmod 700 borgbackup</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_sur_le_serveur_sauvegardé">
<title>Installation sur le serveur sauvegardé</title>
<simpara>Suivez la procédure suivante:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur &lt;example.com&gt;. </link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install borgbackup</programlisting>
</listitem>
<listitem>
<simpara>Copiez la clé publique de root sur le &lt;storing_srv&gt;. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh-copy-id -i ~/.ssh/id_*.pub borgbackup@&lt;storing_srv&gt;</programlisting>
</listitem>
<listitem>
<simpara>Coller le mot de passe généré plus haut lorsqu&#8217;il est demandé</simpara>
</listitem>
<listitem>
<simpara>Affichez votre adresse IP. tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">wget -qO- http://ipecho.net/plain; echo</programlisting>
</listitem>
<listitem>
<simpara>Faites un essai de connexion en tapant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">ssh borgbackup@&lt;storing_srv&gt;</programlisting>
</listitem>
<listitem>
<simpara>Aucun mot de passe ne doit être demandée et vous devez être connecté en tant que borgbackup sur le &lt;storing_srv&gt;</simpara>
</listitem>
<listitem>
<simpara>Si vous êtes très attaché à la sécurité, vous pouvez restreindre l&#8217;accès au seul serveur &lt;example.com&gt;. Tapez sur la ligne de commande du &lt;storing_srv&gt; :</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi ~/.ssh/authorized_keys</programlisting>
</listitem>
<listitem>
<simpara>Ajoutez en première ligne du fichier :</simpara>
<screen>from="SERVERIPADDRESS",command="borg serve --restrict-to-path /home/borgbackup/borgbackup/",no-pty,no-agent-forwarding,no-port-forwarding,no-X11-forwarding,no-user-rc <co xml:id="CO57-1"/></screen>
<calloutlist>
<callout arearefs="CO57-1">
<para>remplacez SERVERIPADDRESS par l&#8217;adresse IP affichée plus tôt.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Fusionnez cette ligne avec la suivante qui démarre par ssh en prenant bien garde de laissez un espace entre no-user-rc et ssh-rsa</simpara>
</listitem>
<listitem>
<simpara>Déconnectez vous en tapant :</simpara>
<programlisting language="bash" linenumbering="unnumbered">exit</programlisting>
</listitem>
<listitem>
<simpara>De retour sur le serveur &lt;example.com&gt;</simpara>
</listitem>
<listitem>
<simpara><link linkend="pass_gen">Créez un mot de passe pour le dépot borg backup</link>.</simpara>
<important>
<simpara>Sauvegardez précieusement ce mot de passe. Il vous sera indispensable pour récupérer vos backup après un crash du serveur. Sans celui-ci, impossible de récupérer votre installation !</simpara>
</important>
</listitem>
<listitem>
<simpara>Puis tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">export BORG_PASSPHRASE='mot_passe' <co xml:id="CO58-1"/></programlisting>
<calloutlist>
<callout arearefs="CO58-1">
<para>mot_passe doit être remplacé par celui généré plus haut</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Initialisez le dépot borg. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">borg init -e repokey-blake2 borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/</programlisting>
</listitem>
<listitem>
<simpara>Tout est maintenant prêt pour faire un backup</simpara>
</listitem>
<listitem>
<simpara>avec le mode <literal>repokey</literal>, une clé de cryptage est stockée dans le repository de backup. Il est conseillé de la sauvegarder. Pour cela, tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">borg key export borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/</programlisting>
</listitem>
<listitem>
<simpara>Notez bien la clé qui sert à décrypter le repository dans un endroit sécurisé
=== Effectuer un backup</simpara>
</listitem>
</orderedlist>
<simpara>Nous allons créer tout d&#8217;abord un script de backup pour sauvegarder tout le serveur sauf les répertoires système:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur &lt;example.com&gt;. </link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /usr/local/bin/borgbackup.sh</programlisting>
</listitem>
<listitem>
<simpara>Insèrez dans le fichier le texte suivant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh
export BORG_PASSPHRASE='mot_passe' <co xml:id="CO59-1"/>
cd / &amp;&amp; /usr/local/bin/borg create --stats --progress --compress zstd borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/::`hostname`-`date +%Y-%m-%d-%H-%M-%S` ./ --exclude=dev --exclude=proc --exclude=run --exclude=root/.cache/ --exclude=mnt/borgmount --exclude=sys --exclude=swapfile --exclude=tmp &amp;&amp; cd <co xml:id="CO59-2"/></programlisting>
<calloutlist>
<callout arearefs="CO59-1">
<para>mot_passe doit être remplacé par celui généré plus haut</para>
</callout>
<callout arearefs="CO59-2">
<para>en fonction de la puissance de votre machine, vous pouvez remplacer l&#8217;algorithme de compression zstd par un algorithme lz4 (rapide) ou  lzma (très lent mais performant en taille).</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>changez les permissions du script. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 700 /usr/local/bin/borgbackup.sh</programlisting>
</listitem>
<listitem>
<simpara>vous pouvez maintenant effectuer une première sauvegarde en tapant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">/usr/local/bin/borgbackup.sh</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_lister_les_backups">
<title>Lister les backups</title>
<simpara>Nous allons créer un script de listage :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur &lt;example.com&gt;. </link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /usr/local/bin/borglist.sh</programlisting>
</listitem>
<listitem>
<simpara>Insèrez dans le fichier le texte suivant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh
export BORG_PASSPHRASE='mot_passe' <co xml:id="CO60-1"/>
/usr/local/bin/borg list -v borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/</programlisting>
<calloutlist>
<callout arearefs="CO60-1">
<para>mot_passe doit être remplacé par celui généré plus haut.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>changez les permissions du script. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 700 /usr/local/bin/borglist.sh</programlisting>
</listitem>
<listitem>
<simpara>vous pouvez maintenant lister vos backup en tapant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">/usr/local/bin/borglist.sh</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_obtenir_les_infos_sur_un_backup">
<title>Obtenir les infos sur un backup</title>
<simpara>Nous allons créer un script de listage :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur &lt;example.com&gt;. </link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /usr/local/bin/borginfo.sh</programlisting>
</listitem>
<listitem>
<simpara>Insèrez dans le fichier le texte suivant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh
export BORG_PASSPHRASE='mot_passe' <co xml:id="CO61-1"/>
/usr/local/bin/borg info --progress borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/::$1</programlisting>
<calloutlist>
<callout arearefs="CO61-1">
<para>mot_passe doit être remplacé par celui généré plus haut.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>changez les permissions du script. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 700 /usr/local/bin/borginfo.sh</programlisting>
</listitem>
<listitem>
<simpara>vous pouvez maintenant lister vos backup en tapant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">/usr/local/bin/borginfo.sh</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_vérifier_un_backup">
<title>Vérifier un backup</title>
<simpara>Nous allons créer un script de vérification :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur &lt;example.com&gt;. </link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /usr/local/bin/borgcheck.sh</programlisting>
</listitem>
<listitem>
<simpara>Insèrez dans le fichier le texte suivant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh
export BORG_PASSPHRASE='mot_passe' <co xml:id="CO62-1"/>
/usr/local/bin/borg check --progress borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/::$1</programlisting>
<calloutlist>
<callout arearefs="CO62-1">
<para>mot_passe doit être remplacé par celui généré plus haut.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>changez les permissions du script. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 700 /usr/local/bin/borgcheck.sh</programlisting>
</listitem>
<listitem>
<simpara>vous pouvez maintenant vérifier un de vos backup en tapant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">/usr/local/bin/borgcheck.sh &lt;nom_de_sauvegarde&gt; <co xml:id="CO63-1"/></programlisting>
<calloutlist>
<callout arearefs="CO63-1">
<para>le nom de sauvegarde est récupéré en utilisant la commande borglist.sh</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_restaurer_un_backup">
<title>Restaurer un backup</title>
<simpara>Nous allons créer un script de montage sous forme de système de fichier :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur &lt;example.com&gt;. </link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /usr/local/bin/borgmount.sh</programlisting>
</listitem>
<listitem>
<simpara>Insérez dans le fichier le texte suivant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh
mkdir -p /mnt/borgbackup
export BORG_PASSPHRASE='mot_passe' <co xml:id="CO64-1"/>
/usr/local/bin/borg mount borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/ /mnt/borgbackup</programlisting>
<calloutlist>
<callout arearefs="CO64-1">
<para>mot_passe doit être remplacé par celui généré plus haut.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>changez les permissions du script. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 700 /usr/local/bin/borgmount.sh</programlisting>
</listitem>
<listitem>
<simpara>vous pouvez maintenant monter vos backups et effectuer des opérations de fichiers. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">/usr/local/bin/borgmount.sh</programlisting>
</listitem>
<listitem>
<simpara>Pour créer un script pour démonter les backups. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /usr/local/bin/borgumount.sh</programlisting>
</listitem>
<listitem>
<simpara>Insérez dans le fichier le texte suivant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh
umount /mnt/borgbackup
rmdir /mnt/borgbackup</programlisting>
</listitem>
<listitem>
<simpara>changez les permissions du script. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 700 /usr/local/bin/borgumount.sh</programlisting>
</listitem>
<listitem>
<simpara>vous pouvez maintenant demonter vos backups. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">/usr/local/bin/borgumount.sh</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_supprimer_vos_vieux_backups">
<title>Supprimer vos vieux backups</title>
<simpara>Nous allons créer un script de ménage des backups :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur &lt;example.com&gt;. </link></simpara>
</listitem>
<listitem>
<simpara>Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /usr/local/bin/borgprune.sh</programlisting>
</listitem>
<listitem>
<simpara>Insèrez dans le fichier le texte suivant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh

# Nettoyage des anciens backups
# On conserve
# - une archive par jour les 7 derniers jours,
# - une archive par semaine pour les 4 dernières semaines,
# - une archive par mois pour les 6 derniers mois.


export BORG_PASSPHRASE='mot_passe' <co xml:id="CO65-1"/>
/usr/local/bin/borg prune --stats --progress borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/ --prefix `hostname`- --keep-daily=7 --keep-weekly=4 --keep-monthly=12 <co xml:id="CO65-2"/></programlisting>
<calloutlist>
<callout arearefs="CO65-1">
<para>mot_passe doit être remplacé par celui généré plus haut.</para>
</callout>
<callout arearefs="CO65-2">
<para>Le nettoyage des sauvegardes va conserver 7 sauvegardes journalières, 4 à la semaine et 12 au mois</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>changez les permissions du script. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 700 /usr/local/bin/borgprune.sh</programlisting>
</listitem>
<listitem>
<simpara>vous pouvez maintenant effectuer du ménage:</simpara>
<programlisting language="bash" linenumbering="unnumbered">/usr/local/bin/borgprune.sh</programlisting>
</listitem>
<listitem>
<simpara>Pour récupèrer l&#8217;espace libéré par la suppression des sauvegardes inutiles, créez le script suivant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /usr/local/bin/borgcompact.sh</programlisting>
</listitem>
<listitem>
<simpara>Insèrez dans le fichier le texte suivant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh

export BORG_PASSPHRASE='mot_passe' <co xml:id="CO66-1"/>
/usr/local/bin/borg compact --progress  borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/</programlisting>
<calloutlist>
<callout arearefs="CO66-1">
<para>mot_passe doit être remplacé par celui généré plus haut.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>changez les permissions du script. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 700 /usr/local/bin/borgcompact.sh</programlisting>
</listitem>
<listitem>
<simpara>vous pouvez maintenant effectuer du ménage:</simpara>
<programlisting language="bash" linenumbering="unnumbered">/usr/local/bin/borgcompact.sh</programlisting>
<simpara>=== Automatisez votre sauvegarde</simpara>
</listitem>
<listitem>
<simpara>Pour créer un script automatisé de backup. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p /var/log/borg
vi /usr/local/bin/borgcron.sh</programlisting>
</listitem>
<listitem>
<simpara>Insérez dans le fichier le texte suivant:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/sh
#
# Script de sauvegarde.
#

set -e

LOG_PATH=/var/log/borg/cron.log

/usr/local/bin/borgbackup.sh &gt;&gt; ${LOG_PATH} 2&gt;&amp;1
/usr/local/bin/borgprune.sh &gt;&gt; ${LOG_PATH} 2&gt;&amp;1
/usr/local/bin/borgcompact.sh &gt;&gt; ${LOG_PATH} 2&gt;&amp;1</programlisting>
</listitem>
<listitem>
<simpara>changez les permissions du script. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">chmod 700 /usr/local/bin/borgcron.sh</programlisting>
</listitem>
<listitem>
<simpara>vous pouvez ensuite planifier votre backup à 1h du matin. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">crontab -e</programlisting>
</listitem>
<listitem>
<simpara>Inserez ensuite le texte suivant:</simpara>
</listitem>
</orderedlist>
<screen># Backup via Borg to backup server
00 01 * * * /usr/local/bin/borgcron.sh</screen>
</section>
<section xml:id="_restauration_durgence">
<title>Restauration d&#8217;urgence.</title>
<simpara>En cas de crash du serveur, l’intérêt du backup offsite est de pouvoir remonter la dernière sauvegarde sans souci.
Pour cela il faut avoir un moyen de booter le serveur dans un mode rescue (boot du VPS en mode rescue, utilisation d&#8217;un clé USB bootable, boot réseau ou autre moyen).</simpara>
<simpara>On suppose dans ce qu&#8217;il suit que vous avez booté sur un linux de type debian ou ubuntu dont la version n&#8217;est pas la toute dernière et dans laquelle borg-backup n&#8217;est pas obligatoirement présent du moins dans un version suffisamment récente.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>loguez vous root sur votre serveur. A noter que, comme vous êtes en mode rescue, l&#8217;accès au mode est indiqué par votre hébergeur ou, si vous avez booté sur une clé USB en local, l&#8217;accès root s&#8217;effectue souvent avec une commande <literal>sudo bash</literal></simpara>
</listitem>
<listitem>
<simpara>Montez votre partition racine. Sur un VPS, la partition est souvent déjà montée dans le répertoire /mnt. Sur un PC c&#8217;est souvent /dev/sda1. Sur un Raspberry Pi cette partition est /dev/mmcblk0p7. Tapez la commande:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p /mnt/root
mount /dev/mmcblk0p7 /mnt/root</programlisting>
</listitem>
<listitem>
<simpara>Installez borgbackup. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install python3-pip libssl-dev cython3 gcc g++ libpython3-dev libacl1-dev python3-llfuse libfuse-dev
pip3 install -U pip setuptools wheel
pip3 install pkgconfig
pip3 install borgbackup[llfuse]</programlisting>
</listitem>
<listitem>
<simpara>Si la compilation échoue, c&#8217;est qu&#8217;il manque des packages. lisez attentivement les logs et installez les packages manquant.</simpara>
</listitem>
<listitem>
<simpara>Munissez vous du mot de passe &lt;mot_passe&gt; des archives borg et tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p /mnt/borgbackup
export BORG_PASSPHRASE='mot_passe' <co xml:id="CO67-1"/>
borg list borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/</programlisting>
<calloutlist>
<callout arearefs="CO67-1">
<para>remplacez mot_passe par votre mot de passe de borg</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>tapez le mot de passe du compte borgbackup.</simpara>
</listitem>
<listitem>
<simpara>la liste des sauvegardes est affichées à l&#8217;écran.</simpara>
</listitem>
<listitem>
<simpara>Choisissez l&#8217;archive qui vous convient et tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd /mnt/root
borg extract --list borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/::&lt;votre_archive&gt;</programlisting>
</listitem>
<listitem>
<simpara>tapez le mot de passe du compte borgbackup.</simpara>
</listitem>
<listitem>
<simpara>la restauration s&#8217;effectue et peut prendre des heures ! soyez patient.</simpara>
</listitem>
<listitem>
<simpara>il peut être nécessaire de réinstaller le bootloader (non utile sur VPS ou raspberry). Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd /mnt/root
chroot . bash
mkdir -p dev proc run sys tmp
mount -t devtmpfs dev /dev
mount -t proc proc /proc
grub_install /dev/sda <co xml:id="CO68-1"/>
umount /proc
umount /dev
sync
exit</programlisting>
<calloutlist>
<callout arearefs="CO68-1">
<para>tapez ici le nom de device de votre disque de boot</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Créez votre fichier de swap en suivant <link linkend="swap_create">la
procédure</link>. Attention le fichier de swap doit être installé dans
<literal>/mnt/root/swapfile</literal></simpara>
</listitem>
<listitem>
<simpara>vous pouvez maintenant rebooter votre machine en mode normal.</simpara>
</listitem>
<listitem>
<simpara>une autre façon de remonter la sauvegarde est d&#8217;extraire un fichier tar.xz directement du serveur de stockage et de transférer cette archive sur la machine en mode rescue puis de décompresser. La commande de génération d&#8217;archive est:</simpara>
<programlisting language="bash" linenumbering="unnumbered">borg export-tar --list borgbackup@&lt;storing_srv&gt;:/home/borgbackup/borgbackup/::&lt;votre_archive&gt; restore.tar.xz</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_installation_de_borgweb">
<title>Installation de Borgweb</title>
<simpara>Borgweb existe en version officielle. Cette version n&#8217;a pas trop d&#8217;intéret pour nous étant donnée qu&#8217;elle n&#8217;interroge pas le serveur de stockage pour obtenir les informations des backups réalisés. Il existe un clone de repository qui implémente une fonctionnalité qui liste tous les backups effectués sur le serveur de stockage</simpara>
<simpara>Suivez la procédure suivante sur le serveur de stockage:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur &lt;storing_srv&gt;. </link></simpara>
</listitem>
<listitem>
<simpara>Installez pip  pour python3 et NPM. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">apt install python3-pip npm</programlisting>
</listitem>
<listitem>
<simpara>Installer le logiciel dans le répertoire <literal>/var/lib/borgweb</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p /var/lib/borgweb
cd /var/lib/borgweb
git clone https://github.com/vche/borgweb.git</programlisting>
</listitem>
<listitem>
<simpara>Dans la version testée, le fichier <literal>README.rst</literal> est utilisé par l&#8217;installeur mais plus présent dans le repo. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd borgweb
touch README.rst</programlisting>
</listitem>
<listitem>
<simpara>Lancez l&#8217;installation. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">pip3 install -e .
cd js
npm install</programlisting>
</listitem>
<listitem>
<simpara>Editez la configuration. Comme la variable d&#8217;environnement <literal>BORG_CONFIG</literal> semble n&#8217;avoir aucun effet, éditez directement le fichier de configuration du repository. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd /var/lib/borgweb/borgweb/borgweb
vi config.py</programlisting>
</listitem>
<listitem>
<simpara>Mettez ce texte dans le fichier édité:</simpara>
<programlisting language="python" linenumbering="unnumbered">class Config(object):
    """This is the basic configuration class for BorgWeb."""

    #: builtin web server configuration
    HOST = '127.0.0.1'  # use 0.0.0.0 to bind to all interfaces
    PORT = 5000  # ports &lt; 1024 need root
    DEBUG=False

    #: borg / borgweb configuration
    LOG_DIR = '/var/log/borg'
    BORG_PATH="/usr/bin/borg"

    # Repo status cache configuration. TTL in secs
    STATUS_CACHE_TTL=43200
    STATUS_CACHE_PATH="/tmp/borgweb.cache"

    BACKUP_REPOS = {
        # Repo  name
        "example.com": { <co xml:id="CO69-1"/>
            # Repo absolute path
            "repo_path": "/home/borgbackup/borgbackup",

            # Repo logs absolute path, or relative to the main LOG_DIR
            "log_path": "/var/log/borg/",

            # Repo password
            "repo_pwd": "your_password", <co xml:id="CO69-2"/>

            # Command/script to run to manually start a backup.
            # If left empty or not specified, the backup won't be
            # manually runnable
            "script": "script",

            # Filled with discovered backups in the repo
            "backups": []
        }
    }</programlisting>
<calloutlist>
<callout arearefs="CO69-2">
<para>Insérez ici le mot de passe du dépot Borg Backup</para>
</callout>
<callout arearefs="CO69-1">
<para>Mettez ici le nom de votre domaine sauvegardé</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Créez un service <literal>systemd</literal>. Editez le fichier de service. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">vi /etc/systemd/system/borgweb.service</programlisting>
</listitem>
<listitem>
<simpara>Insérez dans le fichier le texte suivant:</simpara>
<screen linenumbering="unnumbered">[Unit]
Description=Borgweb Daemon
After=syslog.target network.target

[Service]
WorkingDirectory=/var/lib/borgweb
User=root
Group=root
UMask=0002
Restart=on-failure
RestartSec=5
Type=simple
ExecStart=/usr/local/bin/borgweb
KillSignal=SIGINT
TimeoutStopSec=20
SyslogIdentifier=borgweb

[Install]
WantedBy=multi-user.target</screen>
</listitem>
<listitem>
<simpara>Recharge la base de systemd. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">systemctl daemon-reload</programlisting>
</listitem>
<listitem>
<simpara>Activez et démarrez <literal>borgweb</literal>. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">systemctl enable borgweb.service
systemctl start borgweb.service</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_création_du_site_web_de_borgweb">
<title>Création du site web de Borgweb</title>
<simpara>Appliquez les opérations suivantes Dans ISPConfig de votre serveur de stockage &lt;storing_srv&gt;:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Allez dans la rubrique <literal>DNS</literal>, sélectionnez le menu <literal>Zones</literal>, Sélectionnez votre Zone, Allez dans l&#8217;onglet <literal>Records</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Cliquez sur <literal>A</literal> et saisissez:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Hostname:</literal> &#8592; Tapez <literal>borgweb</literal></simpara>
</listitem>
<listitem>
<simpara><literal>IP-Address:</literal> &#8592; Double cliquez et sélectionnez l&#8217;adresse IP de votre serveur</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Cliquez sur <literal>Save</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Créer un <link linkend="subdomain-site">sub-domain (vhost)</link> dans le configurateur de sites.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Lui donner le nom <literal>borgweb</literal>.</simpara>
</listitem>
<listitem>
<simpara>Le faire pointer vers le web folder <literal>borgweb</literal>.</simpara>
</listitem>
<listitem>
<simpara>Sélectionnez <literal>None</literal> dans <literal>Auto-subdomain</literal></simpara>
</listitem>
<listitem>
<simpara>Activer <literal>let’s encrypt SSL</literal></simpara>
</listitem>
<listitem>
<simpara>Activer <literal>PHP-FPM</literal> pour PHP</simpara>
</listitem>
<listitem>
<simpara>Dans l&#8217;onglet Redirect Cochez la case <literal>Rewrite HTTP to HTTPS</literal></simpara>
</listitem>
<listitem>
<simpara>Laisser le reste par défaut.</simpara>
</listitem>
<listitem>
<simpara>Dans l’onglet Options:</simpara>
</listitem>
<listitem>
<simpara>Dans la boite <literal>Apache Directives:</literal> saisir le texte suivant:</simpara>
<programlisting language="apache" linenumbering="unnumbered">&lt;Proxy *&gt;
Order deny,allow
Allow from all
&lt;/Proxy&gt;

# borgweb httpserver
#

&lt;Location /&gt;
    AllowOverride AuthConfig
    AuthUserFile /var/lib/borgweb/borgweb-htpasswd
    AuthName "Borgweb"
    AuthType Basic
    Require valid-user

&lt;/Location&gt;


ProxyRequests Off
ProxyPass /stats !
ProxyPass /.well-known/acme-challenge !

# borgweb httpserver
#

SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
ProxyPreserveHost    On
ProxyPass / http://localhost:5000/
ProxyPassReverse / http://localhost:5000/

RedirectMatch ^/$ https://borgweb.example.com <co xml:id="CO70-1"/></programlisting>
<calloutlist>
<callout arearefs="CO70-1">
<para>remplacer <literal>example.com</literal> par votre nom de domaine</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><link linkend="root_login">Loguez vous comme root sur &lt;storing_srv&gt;. </link></simpara>
</listitem>
<listitem>
<simpara>Créez ensuite le fichier de mot de passe de borgweb dans votre &lt;storing_srv&gt;:</simpara>
<programlisting language="bash" linenumbering="unnumbered">htpasswd -c /var/lib/borgweb/borgweb-htpasswd admin</programlisting>
</listitem>
<listitem>
<simpara>Tapez <link linkend="pass_gen">votre mot de passe généré</link></simpara>
</listitem>
<listitem>
<simpara>Redémarrez apache. Tapez:</simpara>
<programlisting language="bash" linenumbering="unnumbered">service apache2 restart</programlisting>
</listitem>
<listitem>
<simpara>Pointez votre navigateur sur <link xl:href="https://borgweb.storing_srv">https://borgweb.storing_srv</link> , un mot de passe vous est demandé. Tapez <literal>admin</literal> pour le user et le password saisi. Vous accédez aux informations de sauvegarde de votre site.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_annexe">
<title>Annexe</title>
<section xml:id="_configuration_dun_écran_3_5_inch_rpi_lcd_a">
<title>Configuration d&#8217;un écran 3.5 inch RPI LCD (A)</title>
<section xml:id="_pour_commencer">
<title>Pour commencer</title>
<simpara>Le RPi LCD peut être piloté de deux manières :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>installer le pilote sur votre
Raspbian OS.</simpara>
</listitem>
<listitem>
<simpara>utiliser le fichier image prêt à l&#8217;emploi ou lle pilote LCD est préinstallé.</simpara>
</listitem>
<listitem>
<simpara>Téléchargez la dernière image sur le site web de Raspberry Pi et écrivez-la sur la carte SD.</simpara>
</listitem>
<listitem>
<simpara>Connectez l&#8217;écran LCD RPI à Raspberry Pi et connectez le Pi au réseau.</simpara>
</listitem>
<listitem>
<simpara>Configurez votre Pi :</simpara>
<literallayout class="monospaced">sudo raspi-config</literallayout>
</listitem>
<listitem>
<simpara>configurez ainsi :</simpara>
<itemizedlist>
<listitem>
<simpara>Sélectionnez "Expand Filesystem".</simpara>
</listitem>
<listitem>
<simpara>Boot Option &#8594; Desktop Autologin (peut différer selon la révision Raspbian)</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Ouvrez le terminal du Raspberry PI (Vous devrez peut-être connecter un clavier et un écran LCD HDMI à PI pour l&#8217;installation du pilote). Tapez:</simpara>
<literallayout class="monospaced">git clone https://github.com/waveshare/LCD-show.git
cd LCD-show/</literallayout>
<simpara><emphasis role="strong">Note: Une connexion réseau est nécessaire lors de l&#8217;installation du pilote sur votre Pi, sinon l&#8217;installation ne fonctionnera pas correctement.</emphasis></simpara>
<literallayout class="monospaced">chmod +x LCD35-show
./LCD35-show</literallayout>
</listitem>
<listitem>
<simpara>Après le redémarrage du système, le RPI LCD est prêt à l&#8217;emploi.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_basculer_entre_laffichage_lcd_et_hdmi">
<title>Basculer entre l&#8217;affichage LCD et HDMI</title>
<simpara>Une fois que l&#8217;écran LCD est activé, les paramètres par défaut pour HDMI sont modifiés. Si vous souhaitez utiliser un autre moniteur HDMI, veuillez exécuter la commande suivante :</simpara>
<literallayout class="monospaced">cd LCD-show/
./LCD-hdmi</literallayout>
<simpara>Cela permet de basculer le mode sur l&#8217;affichage LCD :</simpara>
<literallayout class="monospaced">chmod +x LCD35-show
./LCD35-show</literallayout>
</section>
<section xml:id="_paramètres_dorientation_de_lécran">
<title>Paramètres d&#8217;orientation de l&#8217;écran</title>
<simpara>Une fois le pilote tactile installé, l&#8217;orientation de l&#8217;écran peut être définie par ces commandes :</simpara>
<itemizedlist>
<listitem>
<simpara>Rotation de 0 degrés</simpara>
</listitem>
</itemizedlist>
<literallayout class="monospaced">cd LCD-show/
./LCD35-show 0</literallayout>
<itemizedlist>
<listitem>
<simpara>Rotation de 90 degrés</simpara>
</listitem>
</itemizedlist>
<literallayout class="monospaced">cd LCD-show/
./LCD35-show 90</literallayout>
<itemizedlist>
<listitem>
<simpara>Rotation de 180 degrés</simpara>
</listitem>
</itemizedlist>
<literallayout class="monospaced">cd LCD-show/
./LCD35-show 180</literallayout>
<itemizedlist>
<listitem>
<simpara>Rotation de 270 degrés</simpara>
</listitem>
</itemizedlist>
<literallayout class="monospaced">cd LCD-show/
./LCD35-show 270</literallayout>
</section>
<section xml:id="_calibrage_de_lécran_tactile">
<title>Calibrage de l&#8217;écran tactile</title>
<simpara>Cet écran LCD peut être calibré à l&#8217;aide d&#8217;un programme appelé <literal>xinput_calibrator</literal> . Il n&#8217;est pas préinstallé sur le système d&#8217;exploitation Raspbian original. Vous devez donc le télécharger et installer le programme manuellement.</simpara>
<literallayout class="monospaced">sudo apt-get install -y xinput-calibrator</literallayout>
<simpara>Entrez les commandes suivantes pour le calibrage de l&#8217;écran tactile :</simpara>
<literallayout class="monospaced">sudo DISPLAY=:0.0 xinput_calibrator</literallayout>
<simpara>ou Sélectionnez Menu &#8594; Preferences &#8594; Calibrate Touchscreen.</simpara>
<simpara>Après l&#8217;exécution de ces commandes, l&#8217;écran LCD affiche une invite pour un calibrage en quatre points. Cliquez sur les points un par un pour terminer le calibrage tactile. Ensuite, les nouvelles données de calibrage seront affichées dans le terminal, comme indiqué ci-dessous. Veuillez obtenir ces données pour une utilisation ultérieure.</simpara>
<literallayout class="monospaced">Doing dynamic recalibration:
Setting new calibration data: 3919, 208, 236, 3913</literallayout>
<simpara>Tapez la commande suivante pour éditer 99-calibration.conf:</simpara>
<literallayout class="monospaced">sudo nano /etc/X11/xorg.conf.d/99-calibration.conf</literallayout>
<simpara>Ensuite, les anciennes données d&#8217;étalonnage seront affichées dans le terminal :</simpara>
<literallayout class="monospaced">Section "InputClass"
Identifier  "calibration"
MatchProduct    "ADS7846 Touchscreen"
Option  "Calibration"   "160 3723 3896 181"
Option  "SwapAxes"  "1"
EndSection</literallayout>
<simpara>Modifiez les données d&#8217;étalonnage en fonction des nouvelles données d&#8217;étalonnage affichées plus haut :</simpara>
<literallayout class="monospaced">Section "InputClass"
Identifier  "calibration"
MatchProduct    "ADS7846 Touchscreen"
Option  "Calibration"   "3919 208 236 3913"
Option  "SwapAxes"  "1"
EndSection</literallayout>
<simpara>Appuyez sur les touches Ctrl+X, et sélectionnez l&#8217;option Y pour enregistrer la modification.</simpara>
<simpara>La modification sera valide après le redémarrage du système. Entrez la commande suivante pour le redémarrage du système :</simpara>
<literallayout class="monospaced">sudo reboot</literallayout>
<simpara><emphasis role="strong">Notices: En cas de toucher imprécis, veuillez procéder à un nouvel étalonnage de l&#8217;écran et redémarrer le système.</emphasis></simpara>
</section>
<section xml:id="_installer_un_clavier_virtuel">
<title>Installer un clavier virtuel</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Installer matchbox-keyboard</simpara>
<literallayout class="monospaced">sudo apt-get install update
sudo apt-get install matchbox-keyboard
sudo nano /usr/bin/toggle-matchbox-keyboard.sh</literallayout>
</listitem>
<listitem>
<simpara>Copiez les commandes ci-dessous dans toggle-matchbox-keyboard.sh et sauvegardez.</simpara>
<literallayout class="monospaced">#!/bin/bash
#This script toggle the virtual keyboard
PID=`pidof matchbox-keyboard`
if [ ! -e $PID ]; then
killall matchbox-keyboard
else
matchbox-keyboard -s 50 extended&amp;
fi</literallayout>
</listitem>
<listitem>
<simpara>Exécutez les commandes:</simpara>
<literallayout class="monospaced">sudo chmod +x /usr/bin/toggle-matchbox-keyboard.sh
sudo mkdir /usr/local/share/applications
sudo nano /usr/local/share/applications/toggle-matchbox-keyboard.desktop</literallayout>
</listitem>
<listitem>
<simpara>Copiez les commandes ci-dessous dans toggle-matchbox-keyboard.desktop et sauvegardez.</simpara>
<literallayout class="monospaced">[Desktop Entry]
Name=Toggle Matchbox Keyboard
Comment=Toggle Matchbox Keyboard`
Exec=toggle-matchbox-keyboard.sh
Type=Application
Icon=matchbox-keyboard.png
Categories=Panel;Utility;MB
X-MB-INPUT-MECHANSIM=True</literallayout>
</listitem>
<listitem>
<simpara>Exécutez les commandes ci dessous.</simpara>
<simpara><emphasis role="strong">NOTE: Notez que vous devez utiliser les droits d&#8217;utilisateur "Pi" au lieu de root pour exécuter cette commande</emphasis></simpara>
<literallayout class="monospaced">nano ~/.config/lxpanel/LXDE-pi/panels/panel</literallayout>
</listitem>
<listitem>
<simpara>Trouvez la déclaration qui est similaire à celle ci-dessous : (Elle peut être différente dans une autre version)</simpara>
<literallayout class="monospaced">Plugin {
  type = launchbar
  Config {
    Button {
      id=lxde-screenlock.desktop
    }
    Button {
      id=lxde-logout.desktop
    }
  }
}</literallayout>
</listitem>
<listitem>
<simpara>Ajoutez ces déclarations pour ajouter une option de bouton :</simpara>
<literallayout class="monospaced">Button {
  id=/usr/local/share/applications/toggle-matchbox-keyboard.desktop
}</literallayout>
</listitem>
<listitem>
<simpara>redémarrez votre Raspberry Pi. Si le clavier virtuel est correctement installé, vous pouvez constater qu&#8217;il y a une icône de clavier sur la gauche de la barre</simpara>
<literallayout class="monospaced">sudo reboot</literallayout>
</listitem>
</orderedlist>
</section>
<section xml:id="_ressources">
<title>Ressources</title>
<section xml:id="_manuel_utilisateur">
<title>Manuel utilisateur</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://www.waveshare.com/w/upload/1/1e/RPi_LCD_User_Manual_EN.pdf">RPiLCD User Manual</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_images">
<title>Images</title>
<simpara>Description : si vous avez eu du mal à installer le pilote, essayez l&#8217;image avec le pilote préinstallé.</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://drive.google.com/open?id=1xsvANujoImwVQvdf0n7IiUjP8BuCe2GK">RPi-35inch-LCD-(A)-Raspbian-180326.7z</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_driver">
<title>Driver</title>
<simpara>Le pilote peut être téléchargé sur github</simpara>
<literallayout class="monospaced">git clone https://github.com/waveshare/LCD-show.git</literallayout>
</section>
<section xml:id="_fichiers_de_configuration_de_référence">
<title>Fichiers de configuration de référence</title>
<simpara>/boot/cmdline.txt</simpara>
<screen>dwc_otg.lpm_enable=0 console=tty1 console=ttyAMA0,115200 root=/dev/mmcblk0p7 rootfstype=ext4 elevator=deadline rootwait fbcon=map:10 fbcon=font:ProFont6x11 logo.nologo</screen>
<simpara>/boot/config.txt</simpara>
<screen># For more options and information see
# http://www.raspberrypi.org/documentation/configuration/config-txt.md
# Some settings may impact device functionality. See link above for details

# uncomment if you get no picture on HDMI for a default "safe" mode
#hdmi_safe=1

# uncomment this if your display has a black border of unused pixels visible
# and your display can output without overscan
#disable_overscan=1

# uncomment the following to adjust overscan. Use positive numbers if console
# goes off screen, and negative if there is too much border
#overscan_left=16
#overscan_right=16
#overscan_top=16
#overscan_bottom=16

# uncomment to force a console size. By default it will be display's size minus
# overscan.
#framebuffer_width=1280
#framebuffer_height=720

# uncomment if hdmi display is not detected and composite is being output
hdmi_force_hotplug=1

# uncomment to force a specific HDMI mode (this will force VGA)
#hdmi_group=1
#hdmi_mode=1

# uncomment to force a HDMI mode rather than DVI. This can make audio work in
# DMT (computer monitor) modes
#hdmi_drive=2

# uncomment to increase signal to HDMI, if you have interference, blanking, or
# no display
#config_hdmi_boost=4

# uncomment for composite PAL
#sdtv_mode=2

#uncomment to overclock the arm. 700 MHz is the default.
#arm_freq=800

# Uncomment some or all of these to enable the optional hardware interfaces
dtparam=i2c_arm=on
#dtparam=i2s=on
dtparam=spi=on
enable_uart=1
# Uncomment this to enable the lirc-rpi module
#dtoverlay=lirc-rpi

# Additional overlays and parameters are documented /boot/overlays/README

# Enable audio (loads snd_bcm2835)
dtparam=audio=on
dtoverlay=tft35a
#dtoverlay=ads7846,cs=1,penirq=17,penirq_pull=2,speed=1000000,keep_vref_on=1,swapxy=1,pmax=255,xohms=60,xmin=200,xmax=3900,ymin=200,ymax=3900</screen>
<simpara>/etc/inittab</simpara>
<simpara>Ajouter:</simpara>
<screen>#Spawn a getty on Raspberry Pi serial line
T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100</screen>
<simpara>/usr/share/X11/xorg.conf/99-fbturbo.conf</simpara>
<screen>Section "Device"
        Identifier      "Allwinner A10/A13/A20 FBDEV"
        Driver          "fbturbo"
        Option          "fbdev" "/dev/fb1"

        Option          "SwapbuffersWait" "true"
EndSection</screen>
<simpara>/usr/share/X11/xorg.conf.d/40-libinput.conf
/usr/share/X11/xorg.conf.d/45-evdev.conf</simpara>
<screen>Section "InputClass"
        Identifier "libinput pointer catchall"
        MatchIsPointer "on"
        MatchDevicePath "/dev/input/event*"
        Driver "libinput"
EndSection

Section "InputClass"
        Identifier "libinput keyboard catchall"
        MatchIsKeyboard "on"
        MatchDevicePath "/dev/input/event*"
        Driver "libinput"
EndSection

Section "InputClass"
        Identifier "libinput touchpad catchall"
        MatchIsTouchpad "on"
        MatchDevicePath "/dev/input/event*"
        Driver "libinput"
EndSection

Section "InputClass"
        Identifier "libinput touchscreen catchall"
        MatchIsTouchscreen "on"
        MatchDevicePath "/dev/input/event*"
        Driver "libinput"
EndSection

Section "InputClass"
        Identifier "libinput tablet catchall"
        MatchIsTablet "on"
        MatchDevicePath "/dev/input/event*"
        Driver "libinput"
EndSection</screen>
<simpara>/etc/X11/xorg.conf.d/99-calibration.conf</simpara>
<screen>Section "InputClass"
        Identifier      "calibration"
        MatchProduct    "ADS7846 Touchscreen"
        Option  "Calibration"   "3936 227 268 3880"
        Option  "SwapAxes"      "1"
EndSection</screen>
</section>
</section>
</section>
</section>
</article>